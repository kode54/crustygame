audio_get_rate -> (int)
audio_get_channels -> (int)
audio_get_fragment_size -> (int)
audio_set_fragments (int)count
audio_set_enabled (int)enabled
audio_get_samples_needed -> (int)
audio_has_underrun -> (int)

audio_set_buffer (int/float)buffer
audio_get_return (int)return

(first N buffers are the audio channels, where N is the number of channels...
will figure out channel order, but it'll probably just be whatever it is in
SDL.)
audio_add_buffer use_buffer (int)size
    (if use_buffer, copy the buffer set from audio_set_buffer, otherwise create
a silent buffer, int buffers are converted to float)
audio_free_buffer (int)id

(all which operate on an envelope take an id as first argument)
audio_add_envelope -> id
audio_free_envelope (int)id
audio_set_envelope_pos (int)pos
audio_set_envelope_output (int)bufferid
audio_set_envelope_output_pos (int)pos
    (make sure channel buffer positions can't be set)
audio_add_envelope_node (int)pos (float)amp (float)slope (int)length
audio_set_envelope_node (int)num (int)pos (float)amp (float)slope (int)length
audio_set_envelope_loop_start (int)pos
audio_set_envelope_loop_end (int)pos (if==start, end)

(all which operate on a player take an id as first argument)
audio_add_player -> id
audio_free_player (int)id
audio_set_player_input_buffer (int)bufferid
audio_set_player_input_buffer_pos (int)pos
    (overridden when audio_set_player_mode is AUDIO_MODE_PHASE_SOURCE)
audio_set_player_output_buffer (int)bufferid
audio_set_player_output_buffer_pos (int)pos
    (make sure channel buffer positions can't be set)
audio_set_player_output_mode mode
    AUDIO_OUTPUT_REPLACE
    AUDIO_OUTPUT_ADD
    AUDIO_OUTPUT_SUB
audio_set_player_volume (int)bufferid/(float)volume
    (if type is int, assume it's a buffer id, if type is float, assume it's a
constant volume multiplier)
audio_set_player_volume_source_scale (float)scale
    (factor to multiply volume buffer by)
audio_set_player_mode mode
    AUDIO_MODE_SPEED
    AUDIO_MODE_PHASE_SOURCE
audio_set_player_phase_source (int)phaseid
    (only used for AUDIO_MODE_PHASE_SOURCE)
    (range is 0.0 to 1.0 to indicate start to end)
audio_set_player_speed (int)bufferid/(float)speed
    (same as audio_set_player_volume)
audio_set_player_speed_source_scale
    (factor to multiply speed buffer by)
audio_start_player (int)samples -> samples
    (audio player stops if any source buffer runs out)

Player logic overview:  The hope is to figure out all the conditions first and
have the call to generate resolve to a tight for loop, so this whole decision
tree thing will probably be more or less inverted, or at least all the
relevant for conditions will be at the lowest level, and the rest of the
conditions will lead up to that, so there's probably going to be something
like 50 for loops or something.  Actually it's something like 24 * 3 so it's
closer to 72 I guess.
Update: Simplified version should be considerably more sane!
*
for samples < requested_samples &&
    outpos < outsize
mode SPEED
for inpos < size &&
    inpos >= 0
 outpos++
 speed modulator type CONSTANT
 inpos += speed
  volume mode CONSTANT
  sample *= volume * volumescale
   output mode REPLACE
   outbuffer[pos] = sample * volume * volumescale
   output mode ADD
   outbuffer[pos] += sample * volume * volumescale
   output mode SUB
   outbuffer[pos -= sample * volume * volumescale
  volume mode BUFFER
  for volbufferpos < volbuffersize
  volbufferpos++
   sample = sample
    output mode REPLACE
    outbuffer[pos] = sample * volbuffer[volbufferpos] * volumescale
    output mode ADD
    outbuffer[pos] += sample * volbuffer[volbufferpos] * volumescale
    output mode SUB
    outbuffer[pos -= sample * volbuffer[volbufferpos] * volumescale
 speed modulator type BUFFER
 for speedbufferpos < speedbuffersize
 speedbufferpos++
  inpos += speed * speedbuffer[speedbufferpos] * speedscale
mode PHASE_SOURCE
for phasebufferpos < phasebuffersize
phasebufferpos++
 phase buffer type int
 inpos = phasebuffer[phasebufferpos]
 phase buffer type float
 inpos = insize * phasebuffer[phasebufferpos]

hopefully eventually effects to operate on buffers
