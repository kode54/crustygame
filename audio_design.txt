audio_get_rate -> (int)
audio_get_channels -> (int)
audio_get_fragment_size -> (int)
audio_set_fragments (int)count
audio_set_enabled (int)enabled
audio_get_samples_needed -> (int)
audio_has_underrun -> (int)

audio_set_buffer (int/float)buffer
audio_get_return (int)return

(first N buffers are the audio channels, where N is the number of channels...
will figure out channel order, but it'll probably just be whatever it is in
SDL.)
audio_add_buffer use_buffer (int)size
    (if use_buffer, copy the buffer set from audio_set_buffer, otherwise create
a silent buffer, int buffers are converted to float)
audio_free_buffer (int)id

(all which operate on an envelope take an id as first argument)
audio_add_envelope -> id
audio_free_envelope (int)id
audio_set_envelope_pos (int)pos
audio_set_envelope_mode mode
    AUDIO_MODE_ONCE
    AUDIO_MODE_LOOP
    AUDIO_MODE_PINGPONG
audio_set_envelope_output (int)bufferid
audio_set_envelope_output_pos (int)pos
audio_add_envelope_node (int)pos (float)amp (float)slope (int)length
audio_set_envelope_node (int)num (int)pos (float)amp (float)slope (int)length
audio_set_envelope_loop_start (int)pos
audio_set_envelope_loop_end (int)pos (if==start, end)

(all which operate on a player take an id as first argument)
audio_add_player -> id
audio_free_player (int)id
audio_set_player_input_buffer (int)bufferid
audio_set_player_input_buffer_pos (int)pos
    (overridden when audio_set_player_mode is AUDIO_MODE_PHASE_SOURCE)
audio_set_player_output_buffer (int)bufferid
audio_set_player_output_buffer_pos (int)pos
    (make sure channel buffer positions can't be set)
audio_set_player_output_mode mode
    AUDIO_OUTPUT_REPLACE
    AUDIO_OUTPUT_ADD
audio_set_player_volume (int)bufferid/(float)volume
    (if type is int, assume it's a buffer id, if type is float, assume it's a
constant volume multiplier)
audio_set_player_volume_source_scale (float)scale
    (factor to multiply volume buffer by)
audio_set_player_mode mode
    AUDIO_MODE_ONCE
    AUDIO_MODE_LOOP
    AUDIO_MODE_PINGPONG
    AUDIO_MODE_PHASE_SOURCE
audio_set_player_phase_source (int)phaseid
    (only used for AUDIO_MODE_PHASE_SOURCE)
    (range is 0.0 to 1.0 to indicate start to end)
audio_set_player_speed (int)bufferid/(float)speed
    (same as audio_set_player_volume)
audio_set_player_speed_source_scale
    (factor to multiply speed buffer by)
audio_run_player (int)samples -> samples
    (audio player stops if any source buffer runs out)

input indexing modes (7)
ONCE CONSTANT
ONCE MODULATED
LOOP CONSTANT
LOOP MODULATED
PINGPONG CONSTANT
PINGPONG MODULATED
PHASE_MODULATED

output volume modes (2)
CONSTANT
MODULATED

output operation modes (2)
REPLACE
ADD

total permutations 7 * 2 * 2 = 28

*
for samples < requested_samples &&
    outpos < outsize
mode ONCE
if inpos == 0 || inpos == size -> stop
mode LOOP
if inpos == 0 -> inpos = size
if inpos == size -> inpos = 0
mode PINGPONG
if inpos == 0 || inpos == size -> speed = -speed;
 outpos++
 speed modulator type CONSTANT
 inpos += speed
  volume mode CONSTANT
  sample *= volume * volumescale
   output mode REPLACE
   outbuffer[pos] = sample * volume * volumescale
   output mode ADD
   outbuffer[pos] += sample * volume * volumescale
  volume mode BUFFER
  for volbufferpos < volbuffersize
  volbufferpos++
   sample = sample
    output mode REPLACE
    outbuffer[pos] = sample * volbuffer[volbufferpos] * volumescale
    output mode ADD
    outbuffer[pos] += sample * volbuffer[volbufferpos] * volumescale
 speed modulator type BUFFER
 for speedbufferpos < speedbuffersize
 speedbufferpos++
  inpos += speed * speedbuffer[speedbufferpos] * speedscale
mode PHASE_SOURCE
for phasebufferpos < phasebuffersize
phasebufferpos++
 phase buffer type float
 inpos = insize * phasebuffer[phasebufferpos]

hopefully eventually effects to operate on buffers
