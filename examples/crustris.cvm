include crustygame.inc
include fills.inc
include videomode.inc
include timers.inc
binclude gfx ints "crustris.crsg"

expr INITIAL_CHANGE_RATE 500
expr INPUT_DELAY 50
expr TAP_DELAY 2
TILEMAP_COLOR BG   244 169 213 255
TILEMAP_COLOR BG_D  27  80 173 255 
expr BACKGROUND_PATTERN_SHADOW_STRENGTH 48
expr BGSCROLL_DELAY "1000 / 60"

macro SET_VIDEO_MODE
    static videomode string VIDEOMODE
    expr VIDEO_MODE_SET 1
endmacro SET_VIDEO_MODE

macro SET_DEFAULT_VIDEO_MODE
    static videomode string "640x480"
endmacro SET_DEFAULT_VIDEO_MODE

if VIDEOMODE SET_VIDEO_MODE
expr VIDEO_MODE_NOT_SET "VIDEO_MODE_SET ^ 1"
if VIDEO_MODE_NOT_SET SET_DEFAULT_VIDEO_MODE

expr TILE_SIDE 16

expr SCREEN_WIDTH 640
expr SCREEN_HEIGHT 480
expr SCREEN_TILES_WIDTH "SCREEN_WIDTH / TILE_SIDE"
expr SCREEN_TILES_HEIGHT "SCREEN_HEIGHT / TILE_SIDE"
macro RESCALE_POS XPOS YPOS
    mul XPOS global_scale
    mul YPOS global_scale
    add XPOS global_offset:0
    add YPOS global_offset:1
endmacro RESCALE_POS

; assure collision masking works.
static pieces ints "\
255 255 255 \
0   255 0 \
0   255 \
255 255 \
0   255 \
0   255 0 \
255 255 255 \
255 0 \
255 255 \
255 0 \
\
255 255 255 \
0   0   255 \
0   255 \
0   255 \
255 255 \
255 0   0 \
255 255 255 \
255 255 \
255 0 \
255 0 \
\
255 255 0 \
0   255 255 \
0   255 \
255 255 \
255 0 \
\
255 255 \
255 255 \
\
0   255 255 \
255 255 0 \
255 0 \
255 255 \
0   255 \
\
255 255 255 \
255 0   0 \
255 255 \
0   255 \
0   255 \
0   0   255 \
255 255 255 \
255 0 \
255 0 \
255 255 \
\
255 \
255 \
255 \
255 \
255 255 255 255"
; all arrays refering to pieces have a null 0th index since 0 means no piece
; and pieces index starting at 1
expr PIECEINFO_PIECES    7
expr PIECEINFO_ROTATIONS 4
static PIECEINFO_POS ints "\
      0   0   0   0 \
      0   6  12  18 \
     24  30  36  42 \
     48  54  48  54 \
     60  60  60  60 \
     64  70  64  70 \
     76  82  88  94 \
    100 104 100 104"
static PIECEINFO_WIDTH ints "\
    0 0 0 0 \
    3 2 3 2 \
    3 2 3 2 \
    3 2 3 2 \
    2 2 2 2 \
    3 2 3 2 \
    3 2 3 2 \
    1 4 1 4"
static PIECEINFO_HEIGHT ints "\
    0 0 0 0 \
    2 3 2 3 \
    2 3 2 3 \
    2 3 2 3 \
    2 2 2 2 \
    2 3 2 3 \
    2 3 2 3 \
    4 1 4 1"
; left side is starting at transition from rotation 0 to rotation 1 then the
; far right column is the transition from rotation 3 back to 0.
; that is, the rotation transitioned from is the column that should be read
; from.
; for counter-clockwise rotation, the column for the rotation transitioned to
; should be read, then negated.
static ROTATION_X_BIAS ints "\
     0  0  0  0 \
     0  0  1 -1 \
     0  0  1 -1 \
     1 -1  0  0 \
     0  0  0  0 \
     1 -1  0  0 \
     0  0  1 -1 \
    -2  1 -1  2"
static ROTATION_Y_BIAS ints "\
     0  0  0  0 \
    -1  0  0  1 \
    -1  0  0  1 \
     0  1 -1  0 \
     0  0  0  0 \
     0  1 -1  0 \
    -1  0  0  1 \
     2 -2  1 -1"

expr PIT_WIDTH 10
expr PIT_HEIGHT 20
expr PIT_SIZE "PIT_WIDTH * PIT_HEIGHT"
static pit ints PIT_SIZE
static pit_map0_tiles ints PIT_SIZE
static pit_map1_tiles ints PIT_SIZE
static pit_map2_tiles ints PIT_SIZE
static pit_map0_colormod ints PIT_SIZE
static pit_map1_colormod ints PIT_SIZE
static pit_map2_colormod ints PIT_SIZE
expr PIT_BG_WIDTH  "PIT_WIDTH + 2"
expr PIT_BG_HEIGHT "PIT_HEIGHT + 2"
expr PIT_BG_SIZE   "PIT_BG_WIDTH * PIT_BG_HEIGHT"
expr PIT_TILE_CORNER 4
expr PIT_TILE_EDGE   5
expr PIT_TILE_FILL   3
; C_PIT_FILL
TILEMAP_COLOR PIT_FILL 160 160 160 127
expr CLEAR_TILE      1
expr SOLID_TILE      0
expr BACKGROUND_TILE 2

static PIECE_TILEMAP ints "CLEAR_TILE CLEAR_TILE CLEAR_TILE 0 \
                           0  6  7 0 \
                           0  8  9 0 \
                           0 10 11 0 \
                           0 12 13 0 \
                           0 14 15 0 \
                           0 16 17 0 \
                           0 18 19 0"
; Probably should be power of two
static TILEMAP_WIDTH 4
static TILEMAP_HEIGHT 8
TILEMAP_COLOR BL   0   0   0 255
TILEMAP_COLOR  C   0 170 170 255
TILEMAP_COLOR  Y 170 170   0 255
TILEMAP_COLOR  P 170   0 170 255
TILEMAP_COLOR  G   0 170   0 255
TILEMAP_COLOR  R 170   0   0 255
TILEMAP_COLOR  B   0   0 170 255
TILEMAP_COLOR  O 170  85   0 255
TILEMAP_COLOR LC  85 255 255 255
TILEMAP_COLOR LY 255 255  85 255
TILEMAP_COLOR LP 255  85 255 255
TILEMAP_COLOR LG  85 255  85 255
TILEMAP_COLOR LR 255  85  85 255
TILEMAP_COLOR LB  85  85 255 255
TILEMAP_COLOR LO 255 170  85 255
TILEMAP_COLOR  W 255 255 255 255

; 0th is no block
static PIECE_COLORMOD ints "0 0 0 0 \
                            C_C C_LC C_W 0 \
                            C_Y C_LY C_W 0 \
                            C_P C_LP C_W 0 \
                            C_G C_LG C_W 0 \
                            C_R C_LR C_W 0 \
                            C_B C_LB C_W 0 \
                            C_O C_LO C_W 0"

static BACKGROUND_PATTERN ints "\
    BACKGROUND_TILE CLEAR_TILE CLEAR_TILE CLEAR_TILE \
    CLEAR_TILE BACKGROUND_TILE CLEAR_TILE CLEAR_TILE \
    CLEAR_TILE CLEAR_TILE BACKGROUND_TILE CLEAR_TILE \
    CLEAR_TILE CLEAR_TILE CLEAR_TILE BACKGROUND_TILE \
    CLEAR_TILE CLEAR_TILE CLEAR_TILE BACKGROUND_TILE \
    CLEAR_TILE CLEAR_TILE BACKGROUND_TILE CLEAR_TILE \
    CLEAR_TILE BACKGROUND_TILE CLEAR_TILE CLEAR_TILE \
    BACKGROUND_TILE CLEAR_TILE CLEAR_TILE CLEAR_TILE"
expr BACKGROUND_PATTERN_SIDE 4
expr BACKGROUND_PATTERN_SIZE "BACKGROUND_PATTERN_SIDE * \
                              BACKGROUND_PATTERN_SIDE"
expr BACKGROUND_PATTERN_PXSIDE "BACKGROUND_PATTERN_SIDE * TILE_SIDE"
expr BACKGROUND_WIDTH  "SCREEN_TILES_WIDTH + 4"
expr BACKGROUND_HEIGHT "SCREEN_TILES_HEIGHT + 4"
expr BACKGROUND_SIZE   "BACKGROUND_WIDTH * BACKGROUND_HEIGHT"
expr PIT_PATTERN_WIDTH  "PIT_BG_WIDTH + 4"
expr PIT_PATTERN_HEIGHT "PIT_BG_HEIGHT + 4"

proc populate_piece_values piece rotation pos width height
    local pieceptr

    ; copy values to locals to not mutate caller variables
    move pieceptr piece
    mul  pieceptr PIECEINFO_ROTATIONS
    add  pieceptr rotation

    move pos PIECEINFO_POS:pieceptr
    move width PIECEINFO_WIDTH:pieceptr
    move height PIECEINFO_HEIGHT:pieceptr
ret
 
proc rotate x y piece rotation dir
    local biasptr

    cmp dir 0
    jumpl rotate_ccw
    jumpg rotate_cw
    jump end

    label rotate_ccw
    sub rotation 1
    jumpg no_wrap_max
    jumpz no_wrap_max
    move rotation 3
    label no_wrap_max

    ; for counter clockwise, the pointer is the rotation transitioned to
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    ; for counter clockwise, the bias is subtracted (undone)
    sub x ROTATION_X_BIAS:biasptr
    sub y ROTATION_Y_BIAS:biasptr
    jump end

    label rotate_cw
    ; for clockwise, the pointer is the rotation transitioned from
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    add rotation 1
    cmp rotation 4
    jumpl no_wrap_0
    move rotation 0
    label no_wrap_0

    ; for clockwise, the bias is added
    add x ROTATION_X_BIAS:biasptr
    add y ROTATION_Y_BIAS:biasptr
    
    label end
ret

expr COLLIDED_LEFT   1
expr COLLIDED_RIGHT  2
expr COLLIDED_TOP    4
expr COLLIDED_BOTTOM 8

proc check_collision collided x y pos width height
    local piecex
    local piecey
    local pitpos
    local piecepos
    local pieceval
    local halfwidth
    local halfheight
    local leftx
    local rightx
    local topy
    local bottomy

    move collided 0
    ; determine ranges where a collision is determined to be to a particular
    ; side. this could be made smaller but it wouldn't necessarily be faster
    ; and would be more difficult to understand when it's already janky
    move halfwidth width
    mod  halfwidth 2
    jumpz split_width
    ; odd number.  be greedy here and count the center piece outwards for both
    ; sides.  a bottom collision could result in both being flagged but that
    ; isn't important
    ; assume that integer divisions will be floored down
    move leftx width
    div  leftx 2
    move rightx leftx
    add  leftx 1
    jump find_halfheight
    label split_width
    move leftx width
    div  leftx 2
    move rightx leftx
    label find_halfheight
    move halfheight height
    mod  halfheight 2
    jumpz split_height
    ; as above
    move topy height
    div  topy 2
    move bottomy topy
    add  topy 1
    jump done_halves
    label split_height
    move topy height
    div  topy 2
    move bottomy topy
    label done_halves

    ; check collisions with pit boundaries
    ; check top
    cmp y 0
    jumpg check_pit_bottom
    jumpz check_pit_bottom
    or collided COLLIDED_TOP
    jump end

    label check_pit_bottom
    move piecey y
    add  piecey height
    cmp  piecey PIT_HEIGHT
    jumpl check_pit_left
    jumpz check_pit_left
    or collided COLLIDED_BOTTOM
    jump end

    label check_pit_left
    cmp x 0
    jumpg check_pit_right
    jumpz check_pit_right
    or collided COLLIDED_LEFT
    jump end

    label check_pit_right
    move piecex x
    add  piecex width
    cmp  piecex PIT_WIDTH
    jumpl check_pit
    jumpz check_pit
    or collided COLLIDED_RIGHT
    jump end

    label check_pit
    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    move piecepos pos
    move piecey 0
    label y
        move piecex 0

        label x
            move pieceval pieces:piecepos
            and  pieceval pit:pitpos
            jumpz no_collision

            ; determine what halves a collision happened on
            ; left side
            cmp piecex leftx
            jumpg check_right
            jumpz check_right
            or collided COLLIDED_LEFT
            label check_right
            cmp piecex rightx
            jumpl check_top
            or collided COLLIDED_RIGHT
            label check_top
            cmp piecey topy
            jumpg check_bottom
            jumpz check_bottom
            or collided COLLIDED_TOP
            label check_bottom
            cmp piecey bottomy
            jumpl no_collision
            or collided COLLIDED_BOTTOM
            label no_collision

            add piecepos 1
            add pitpos 1
            add piecex 1
            cmp piecex width
        jumpl x

        sub pitpos width
        add pitpos PIT_WIDTH
        add piecey 1
        cmp piecey height
    jumpl y

    label end
ret

proc try_resolve_piece_movement piece rotation x y xmove ymove dir
    local pos
    local oldwidth
    local oldheight
    local width
    local height
    local xbias
    local ybias
    local newrotation
    local widthdiff
    local heightdiff
    local leftgrowth
    local rightgrowth
    local topgrowth
    local bottomgrowth
    local checkx
    local checky
    local collided
    local priority

    ; get the current and desired new piece stats
    call populate_piece_values piece rotation pos oldwidth oldheight
    move newrotation rotation
    call rotate xbias ybias piece newrotation dir
    call populate_piece_values piece newrotation pos width height

    ; try to do the full move
    move checkx x
    add  checkx xmove
    add  checkx xbias
    move checky y
    add  checky ymove
    add  checky ybias
    call check_collision priority checkx checky pos width height
    cmp priority
    jumpz update_all

    ; compare them to see if we need to check for left/right or up/down kicks,
    ; there can only be one or the other or neither for the O piece or if no
    ; rotation happened anyway
    move widthdiff width
    sub  widthdiff oldwidth
    move heightdiff height
    sub  heightdiff oldheight

    cmp widthdiff 0
    jumpg horz_kick
    cmp heightdiff 0
    jumpg vert_kick
    ; no rotation occurred or the piece doesn't occupy additional space so it
    ; doesn't need to kick, still update rotation anyway.
    move rotation newrotation
    jump no_kick

    label horz_kick
        ; determine growth in both directions and try all possibilities from
        ; outside in

        ; xbias will always be 0 or negative indicating the piece has to move
        ; to grow in that direction
        move leftgrowth xbias
        mul  leftgrowth -1

        ; start with the growth in the left direction, if any, find the width
        ; past the 0 point, then subtract the original width
        move rightgrowth xbias
        add  rightgrowth width
        sub  rightgrowth oldwidth

        ; and finally apply the attempted movement
        sub  leftgrowth  xmove
        add  rightgrowth xmove

        ; apply drop, if any
        move checky y
        add  checky ymove

        ; try the largest of leftgrowth and rightgrowth (or the side that
        ; collided if they are equal), decrement by one then repeat until 
        ; they're both zero
        label horz_kick_loop
            cmp leftgrowth 0
            jumpg horz_loop_continue
            cmp rightgrowth 0
            jumpg horz_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump no_kick
            label horz_loop_continue
                cmp leftgrowth rightgrowth
                jumpg try_left
                jumpl try_right
                and priority COLLIDED_LEFT
                jump try_left

            label try_right
                ; actually try moving it to the left to _compensate_ for right
                ; side growth
                move checkx x
                add  checkx xbias
                sub  checkx rightgrowth

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub rightgrowth 1
                cmp collided
                jumpn horz_kick_loop

                ; found open spot, update values and finish
                move x checkx
                move y checky
                move rotation newrotation
            jump horz_loop_break
            label try_left
                ; same as above but moving right to compensate for left hand
                ; growth
                move checkx x
                add  checkx xbias
                add  checkx leftgrowth

                call check_collision collided checkx checky pos width height
                ; same as above
                sub leftgrowth 1
                cmp collided
                jumpn horz_kick_loop

                ; also as above 
                move x checkx
                move y checky
                move rotation newrotation
            ; break out here
        label horz_loop_break
    jump end

    label vert_kick
        ; should be pretty much like horz_kick just in a vertical direction

        ; ybias will always be 0 or negative indicating the piece has to move
        ; to grow in that direction
        move topgrowth ybias
        mul  topgrowth -1

        ; start with the growth upwards, if any, find the height
        ; past the 0 point, then subtract the original height
        move bottomgrowth ybias
        add  bottomgrowth height
        sub  bottomgrowth oldheight

        ; and finally apply the attempted movement
        sub  topgrowth    ymove
        add  bottomgrowth ymove

        ; apply horizontal movement, if any
        move checkx x
        add  checkx xmove

        ; try the largest of topgrowth and bottomgrowth (or the side that
        ; collided if they are equal), decrement by one then repeat until 
        ; they're both zero
        label vert_kick_loop
            cmp topgrowth 0
            jumpg vert_loop_continue
            cmp bottomgrowth 0
            jumpg vert_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump no_kick
            label vert_loop_continue
                cmp topgrowth bottomgrowth
                jumpg try_up
                jumpl try_down
                cmp priority COLLIDED_TOP
                jumpn try_up

            label try_down
                ; actually try moving it up to _compensate_ for bottom
                ; growth
                move checky y
                add  checky ybias
                sub  checky bottomgrowth

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub bottomgrowth 1
                cmp collided
                jumpn vert_kick_loop

                ; found open spot, update values and finish
                move x checkx
                move y checky
                move rotation newrotation
            jump vert_loop_break
            label try_up
                ; same as above but moving down to compensate for upward
                ; growth
                move checky y
                add  checky ybias
                add  checky topgrowth

                call check_collision collided checkx checky pos width height
                ; same as above
                sub topgrowth 1
                cmp collided
                jumpn vert_kick_loop

                ; also as above 
                move x checkx
                move y checky
                move rotation newrotation
            ; break out here
        label vert_loop_break
    jump end

    label no_kick
        ; try to move the piece in both requested directions
        move checkx x
        add  checkx xmove
        move checky y
        add  checky ymove
        call check_collision collided checkx checky pos width height
        cmp collided
        jumpz update_pos
        ; if either is 0, don't repeat an unnecessary test
        cmp xmove 0
        jumpz end
        cmp ymove 0
        jumpz end

        ; try to move the piece down only
        cmp ymove 0
        jumpz no_down_only
            move checkx x
            move checky y
            add  checky ymove
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
        label no_down_only

        ; try to move piece only laterally
        cmp xmove 0
        jumpz no_lateral_only
            move checkx x
            add  checkx xmove
            move checky y
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
       label no_lateral_only
    jump end

    label update_all
        move rotation newrotation
    label update_pos
        move x checkx
        move y checky
    label end
ret

proc update_pit_map piece rotation x y
    local piecex
    local pos
    local width
    local height
    local pitpos

    call populate_piece_values piece rotation pos width height

    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    label y
        move piecex width

        label x
            cmp pieces:pos
            jumpz no_update
                move pit:pitpos piece
            label no_update

            add pos 1
            add pitpos 1
            sub piecex 1
        jumpg x

        ; advance to the next row of the pit
        sub pitpos width
        add pitpos PIT_WIDTH
        sub height 1
    jumpg y
ret

proc update_pit_tilemaps x y w h
    local i
    local j
    local startptr
    local ptr
    local pitval

    move startptr y
    mul  startptr PIT_WIDTH
    add  startptr x

    move ptr startptr
    move j h
    label y
        move i w
        label x
            move pitval pit:ptr
            mul  pitval TILEMAP_WIDTH
            move pit_map0_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map0_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map1_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map1_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map2_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map2_colormod:ptr PIECE_COLORMOD:pitval
            sub  pitval 2

            add ptr 1
            sub i 1
        jumpg x
        sub ptr w
        add ptr PIT_WIDTH
        sub j 1
    jumpg y

    ; set tiles and attributes then update
    call gfx_set_tilemap_map3 pit_tilemap_id0 pit_map0_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id0 pit_map0_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id0 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id1 pit_map1_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id1 pit_map1_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id1 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id2 pit_map2_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id2 pit_map2_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id2 x y w h
ret

proc update_pit_tilemaps_from_piece piece rotation x y
    local pos
    local width
    local height

    call populate_piece_values piece rotation pos width height
    call update_pit_tilemaps x y width height
ret

proc draw_pit
    move gfx_draw_layer pit_shadow_layer_id
    move gfx_draw_layer pit_pattern1_layer_id
    move gfx_draw_layer pit_pattern0_layer_id
    move gfx_draw_layer pit_background_layer_id
    move gfx_draw_layer pit_layer_id0
    move gfx_draw_layer pit_layer_id1
    move gfx_draw_layer pit_layer_id2
ret

proc draw_piece layer_id piece rotation x y
    local scaledx
    local scaledy
    local piecex
    local pos
    local width
    local height
    local window ints 2
    local position floats "0.0 0.0"
    local intPosition ints 2
    local scaled_tile floats 0.0

    call populate_piece_values piece rotation pos width height

    ; initial tilemap position
    move window:1 piece
    mul  window:1 TILE_SIDE 

    ; size of a tile in float which will be used to accumulate location
    move scaled_tile TILE_SIDE
    mul  scaled_tile global_scale

    ; get the starting scaled position
    move scaledx x
    mul  scaledx global_scale
    add  scaledx global_offset:0
    move scaledy y
    mul  scaledy global_scale
    add  scaledy global_offset:1

    ; get initial y position
    move position:1 scaledy
 
    label y
        ; copy in to a storage useful by gfx
        move intPosition:1 position:1

        ; get initial x position
        move position:0 scaledx
        move piecex width
        label x
            cmp pieces:pos
            jumpz nodraw

            ; copy to an int to be useful by gfx
            move intPosition:0 position:0
            move gfx_set_layer_pos:layer_id intPosition
            move window:0 0
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            label nodraw

            ; advance table pointer
            add pos 1
            ; calculate next x position
            add position:0 scaled_tile
            sub piecex 1
        jumpg x

        ; calculate next y position
        add position:1 scaled_tile
        sub height 1
    jumpg y 
ret

static gfx_id
static block_tilemap_id
static block_layer_id
static pit_tilemap_id0
static pit_tilemap_id1
static pit_tilemap_id2
static pit_layer_id0
static pit_layer_id1
static pit_layer_id2
static pit_background_id
static pit_background_layer_id
static window_background_id
static window_background_layer_id
static window_pattern0_id
static window_pattern0_layer_id
static window_pattern1_id
static window_pattern1_layer_id
static pit_shadow_id
static pit_shadow_layer_id
static pit_pattern0_id
static pit_pattern1_id
static pit_pattern0_layer_id
static pit_pattern1_layer_id
static global_scale floats "0.0 0.0"
static global_offset ints 2

expr BLOCK_OBJ    0
expr PIT0_OBJ     1
expr PIT1_OBJ     2
expr PIT2_OBJ     3
expr PIT_BG_OBJ   4
expr WIN_BG_OBJ   5
expr PIT_SH_OBJ   6
expr WIN_PAT0_OBJ 7
expr WIN_PAT1_OBJ 8
expr PIT_PAT0_OBJ 9
expr PIT_PAT1_OBJ 10
expr TOTAL_OBJ    11
static objects_id ints TOTAL_OBJ
static objects_x  ints TOTAL_OBJ
static objects_y  ints TOTAL_OBJ

macro SET_OBJ_ID OBJ ID
    move objects_id:OBJ ID
endmacro SET_OBJ_ID

macro SET_OBJ_POS OBJ X Y
    move objects_x:OBJ X
    move objects_y:OBJ Y
endmacro SET_OBJ_POS

proc update_obj_scale obj
    local pos ints 2
    local id

    move pos:0 objects_x:obj
    move pos:1 objects_y:obj
    RESCALE_POS pos:0 pos:1
    move id    objects_id:obj

    move gfx_set_layer_pos:id   pos
    move gfx_set_layer_scale:id global_scale
ret

proc update_obj_scales
    local obj TOTAL_OBJ
    sub   obj 1

    label loop
        call update_obj_scale obj
        sub obj 1
    jumpg loop
    jumpz loop
ret

static pitxpos
static pitypos

proc update_scale
    local tempf floats "0.0 0.0 0.0 0.0"
    local temp ints 2

    move tempf:0 gfx_get_width
    move tempf:1 gfx_get_height
    div  tempf:0 SCREEN_WIDTH
    div  tempf:1 SCREEN_HEIGHT
    cmp  tempf:0 tempf:1
    jumpl scale_taller
    jumpg scale_wider
    ; scale equal, keep offset 0
    move global_scale:0 tempf:0
    move global_scale:1 tempf:0
    label scale_taller
    ; center vertically
    move global_scale:0 tempf:0
    move global_scale:1 tempf:0
    mul  tempf:0 SCREEN_HEIGHT
    move global_offset:1 gfx_get_height
    sub  global_offset:1 tempf:0
    div  global_offset:1 2
    move global_offset:0 0
    jump scale_done
    label scale_wider
    ; center horizontally
    move global_scale:0 tempf:1
    move global_scale:1 tempf:1
    mul  tempf:1 SCREEN_WIDTH
    move global_offset:0 gfx_get_width
    sub  global_offset:0 tempf:1
    div  global_offset:0 2
    move global_offset:1 0
    label scale_done

    ; center the pit
    move tempf:0 SCREEN_WIDTH
    move tempf:2 PIT_WIDTH
    mul  tempf:2 TILE_SIDE
    sub  tempf:0 tempf:2
    div  tempf:0 2
    move tempf:1 SCREEN_HEIGHT
    move tempf:2 PIT_HEIGHT
    mul  tempf:2 TILE_SIDE
    sub  tempf:1 tempf:2
    div  tempf:1 2
    move tempf:2 tempf:0
    move tempf:3 tempf:1
    sub  tempf:2 TILE_SIDE
    sub  tempf:3 TILE_SIDE
    move pitxpos tempf:0
    move pitypos tempf:1
    SET_OBJ_POS PIT0_OBJ pitxpos pitypos
    SET_OBJ_POS PIT1_OBJ pitxpos pitypos
    SET_OBJ_POS PIT2_OBJ pitxpos pitypos
    move temp:0 tempf:2
    move temp:1 tempf:3
    SET_OBJ_POS PIT_BG_OBJ temp:0 temp:1
    SET_OBJ_POS PIT_SH_OBJ pitxpos pitypos
    SET_OBJ_POS PIT_PAT0_OBJ pitxpos pitypos
    SET_OBJ_POS PIT_PAT1_OBJ pitxpos pitypos

    call update_obj_scales
ret

static change_rate INITIAL_CHANGE_RATE
expr FPS_TIMER_ID 0
expr PIECE_TIMER_ID 1
expr INPUT_TIMER_ID 2
expr BGSCROLL_TIMER_ID 3

static bgscroll0 ints 2
static bgscroll1 ints 2
static bgscroll2 ints 2
static bgscroll3 ints 2

proc init
    local temp ints 4
    local tempf floats "0.0 0.0"
    local pitbg ints PIT_BG_SIZE 
    local pitflags ints PIT_BG_SIZE 
    local pitcolormod ints PIT_BG_SIZE
    local row ints SCREEN_TILES_WIDTH
    local rowcolormod ints SCREEN_TILES_WIDTH
    local background_pattern ints BACKGROUND_SIZE

    call set_video_mode temp videomode
    cmp temp
    jumpn mode_ok
    move set_running 0
    jump end
    label mode_ok

    move temp:0 gfx:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset gfx:CRSG_OFFSET_DATA gfx:CRSG_OFFSET_WIDTH gfx:CRSG_OFFSET_HEIGHT temp:0 TILE_SIDE TILE_SIDE gfx_id

    call gfx_add_tilemap TILEMAP_WIDTH TILEMAP_HEIGHT block_tilemap_id
    move gfx_set_tilemap_tileset:block_tilemap_id gfx_id
    call gfx_set_tilemap_map block_tilemap_id PIECE_TILEMAP
    call gfx_set_tilemap_attr_colormod block_tilemap_id PIECE_COLORMOD
    call gfx_update_tilemap block_tilemap_id
    call gfx_add_layer block_tilemap_id block_layer_id
    SET_OBJ_ID BLOCK_OBJ block_layer_id
    move temp:0 TILE_SIDE
    move temp:1 TILE_SIDE
    move gfx_set_layer_window:block_layer_id temp
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_background_id
    move gfx_set_tilemap_tileset:pit_background_id gfx_id
    call gfx_add_layer pit_background_id pit_background_layer_id
    SET_OBJ_ID PIT_BG_OBJ pit_background_layer_id

    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id0
    move gfx_set_tilemap_tileset:pit_tilemap_id0 gfx_id
    call gfx_add_layer pit_tilemap_id0 pit_layer_id0
    SET_OBJ_ID PIT0_OBJ pit_layer_id0
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id1
    move gfx_set_tilemap_tileset:pit_tilemap_id1 gfx_id
    call gfx_add_layer pit_tilemap_id1 pit_layer_id1
    SET_OBJ_ID PIT1_OBJ pit_layer_id1
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id2
    move gfx_set_tilemap_tileset:pit_tilemap_id2 gfx_id
    call gfx_add_layer pit_tilemap_id2 pit_layer_id2
    SET_OBJ_ID PIT2_OBJ pit_layer_id2
  
    ; don't really care that pit* aren't static because the background is only
    ; set up once and it doesn't matter if the pointer becomes invalid.
    call fill_with_border pitbg PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_FILL PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER
    call gfx_set_tilemap_map pit_background_id pitbg
    call fill_with_border pitflags PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH 0 0 TILEMAP_HFLIP_MASK TILEMAP_ROTATE_90 0 TILEMAP_ROTATE_90 TILEMAP_VFLIP_MASK 0 TILEMAP_BFLIP_MASK
    call gfx_set_tilemap_attr_flags pit_background_id pitflags
    call fill_with_border pitcolormod PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH C_W C_W C_W C_W C_PIT_FILL C_W C_W C_W C_W
    call gfx_set_tilemap_attr_colormod pit_background_id pitcolormod
    call gfx_update_tilemap pit_background_id
    
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_shadow_id
    move gfx_set_tilemap_tileset:pit_shadow_id gfx_id
    call gfx_add_layer pit_shadow_id pit_shadow_layer_id
    SET_OBJ_ID PIT_SH_OBJ pit_shadow_id
    call fill row PIT_BG_WIDTH 1 PIT_BG_WIDTH SOLID_TILE
    call gfx_set_tilemap_map3 pit_shadow_id row 0 0 0 PIT_BG_WIDTH PIT_BG_HEIGHT
    call fill rowcolormod PIT_BG_WIDTH 1 PIT_BG_WIDTH C_BG_D
    call gfx_set_tilemap_attr_colormod3 pit_shadow_id rowcolormod 0 0 0 PIT_BG_WIDTH PIT_BG_HEIGHT
    call gfx_update_tilemap pit_shadow_id

    call gfx_add_tilemap SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT window_background_id
    move gfx_set_tilemap_tileset:window_background_id gfx_id
    call gfx_add_layer window_background_id window_background_layer_id
    SET_OBJ_ID WIN_BG_OBJ window_background_layer_id
    SET_OBJ_POS WIN_BG_OBJ 0 0
    call fill row SCREEN_TILES_WIDTH 1 SCREEN_TILES_WIDTH SOLID_TILE
    ; pitch = 0 so the same row is copied for each row
    call gfx_set_tilemap_map3 window_background_id row 0 0 0 SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT
    call fill rowcolormod SCREEN_TILES_WIDTH 1 SCREEN_TILES_WIDTH C_BG
    call gfx_set_tilemap_attr_colormod3 window_background_id rowcolormod 0 0 0 SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT
    call gfx_update_tilemap window_background_id

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap BACKGROUND_WIDTH BACKGROUND_HEIGHT window_pattern0_id
    call gfx_add_tilemap BACKGROUND_WIDTH BACKGROUND_HEIGHT window_pattern1_id
    move gfx_set_tilemap_tileset:window_pattern0_id gfx_id
    move gfx_set_tilemap_tileset:window_pattern1_id gfx_id
    call gfx_add_layer window_pattern0_id window_pattern0_layer_id
    call gfx_add_layer window_pattern1_id window_pattern1_layer_id
    call gfx_set_tilemap_map window_pattern0_id background_pattern
    call gfx_update_tilemap window_pattern0_id
    call gfx_set_tilemap_map window_pattern1_id background_pattern
    call gfx_update_tilemap window_pattern1_id
    move temp:0 SCREEN_TILES_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 SCREEN_TILES_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:window_pattern0_layer_id temp
    move gfx_set_layer_window:window_pattern1_layer_id temp
    move gfx_set_layer_blendmode:window_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_alphamod:window_pattern1_layer_id BACKGROUND_PATTERN_SHADOW_STRENGTH
    SET_OBJ_ID WIN_PAT0_OBJ window_pattern0_layer_id
    SET_OBJ_POS WIN_PAT0_OBJ 0 0
    SET_OBJ_ID WIN_PAT1_OBJ window_pattern1_layer_id
    SET_OBJ_POS WIN_PAT1_OBJ 0 0

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN:BACKGROUND_PATTERN_SIZE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT pit_pattern0_id
    call gfx_add_tilemap PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT pit_pattern1_id
    move gfx_set_tilemap_tileset:pit_pattern0_id gfx_id
    move gfx_set_tilemap_tileset:pit_pattern1_id gfx_id
    call gfx_add_layer pit_pattern0_id pit_pattern0_layer_id
    call gfx_add_layer pit_pattern1_id pit_pattern1_layer_id
    call gfx_set_tilemap_map3 pit_pattern0_id background_pattern 0 0 BACKGROUND_WIDTH PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT
    call gfx_update_tilemap pit_pattern0_id
    call gfx_set_tilemap_map3 pit_pattern1_id background_pattern 0 0 BACKGROUND_WIDTH PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT
    call gfx_update_tilemap pit_pattern1_id
    move temp:0 PIT_BG_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 PIT_BG_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:pit_pattern0_layer_id temp
    move gfx_set_layer_window:pit_pattern1_layer_id temp
    move gfx_set_layer_blendmode:pit_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_alphamod:pit_pattern1_layer_id BACKGROUND_PATTERN_SHADOW_STRENGTH
    SET_OBJ_ID PIT_PAT0_OBJ pit_pattern0_layer_id
    SET_OBJ_ID PIT_PAT1_OBJ pit_pattern1_layer_id

    ; update the whole pit
    call update_pit_tilemaps 0 0 PIT_WIDTH PIT_HEIGHT

    call update_scale

    call set_timer_rate FPS_TIMER_ID 1000
    call set_timer_rate PIECE_TIMER_ID change_rate
    call set_timer_rate INPUT_TIMER_ID INPUT_DELAY
    call set_timer_rate BGSCROLL_TIMER_ID BGSCROLL_DELAY

    move bgscroll0:0 0
    move bgscroll0:1 0
    move bgscroll1:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:0 1
    move bgscroll1:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:1 1
    move bgscroll2:0 0
    move bgscroll2:1 0
    move bgscroll3:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:0 1
    move bgscroll3:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:1 1
    move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
    move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
    move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
    move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3

    label end
ret

static fps

proc count_fps
    local elapsed

    call check_timer elapsed FPS_TIMER_ID
    cmp elapsed
    jumpz fps_continue
    move err fps
    move err NL
    move fps 0

    label fps_continue
    add fps 1
ret

proc pit_effect
    local piece
    local rotation
    local width
    local height
    local pos
    local maxx
    local maxy
    local x
    local y

    move piece get_random
    mod  piece PIECEINFO_PIECES
    add  piece 1
    move rotation get_random
    mod  rotation PIECEINFO_ROTATIONS

    call populate_piece_values piece rotation pos width height

    move maxx PIT_WIDTH
    sub  maxx width
    add  maxx 1
    move maxy PIT_HEIGHT
    sub  maxy height
    add  maxy 1
    move x get_random
    mod  x maxx
    move y get_random
    mod  y maxy

    call update_pit_map piece rotation x y
    call update_pit_tilemaps_from_piece piece rotation x y
ret

macro ADVANCE_BGSCROLL VAR DIR MAX
    add VAR DIR
    cmp VAR MAX
    jumpz wrap_VAR_0
    cmp VAR 0
    jumpl wrap_VAR_max
    jump wrap_VAR_done
    label wrap_VAR_0
    move VAR 0
    jump wrap_VAR_done
    label wrap_VAR_max
    move VAR MAX
    sub  VAR 1
    label wrap_VAR_done
endmacro ADVANCE_BGSCROLL

static curpiece 0
static currotation
static xpos 0
static ypos 0
static lastmove 0
static move 0
static tapped 0
static fall 0
static rotate 0

proc frame
    local curTick
    local width
    local height
    local pos
    local elapsed
    local xmove
    local ymove
    local collided

;    call count_fps

    cmp curpiece
    jumpn have_piece
        move curpiece get_random
        mod  curpiece PIECEINFO_PIECES
        add  curpiece 1
        move currotation 0
        move ypos 0
        call populate_piece_values curpiece currotation pos width height
        move xpos PIT_WIDTH
        sub  xpos width
        div  xpos 2
    label have_piece

    ; nothing to do if lastmove and move are equal since there's no state to
    ; transition to
    cmp lastmove move
    jumpz done_tap

    cmp move 0
    jumpl tap_left
    jumpg tap_right
    ; transition to 0, rearm to allow more tapping.
    move lastmove 0
    jump done_tap

    label tap_left
    cmp move lastmove
    jumpz done_tap
    ; transition to left, move left and set lastmove to move to make sure a
    ; tap isn't signaled until lastmove has been reset back to 0 if the user
    ; has indicated to stop.  initialize tapped to allow a delay before the
    ; motion repeats.
    move xmove -1
    move lastmove move
    move tapped TAP_DELAY
    jump done_tap

    label tap_right
    cmp move lastmove
    jumpz done_tap
    ; same as above
    move xmove 1
    move lastmove move
    move tapped TAP_DELAY
    label done_tap

    call check_timer elapsed INPUT_TIMER_ID
    cmp elapsed
    jumpz done_repeat

    cmp fall
    jumpz no_fall
    move ymove 1
    label no_fall

    ; the timer has elapsed, check to see if lastmove and move are equal,
    ; tapped is 0 (and if not, decrease it), then figure out what to do with
    ; move
    cmp move lastmove
    jumpn done_repeat
    cmp tapped 0
    jumpn dec_tapped
    cmp move 0
    jumpl move_left
    jumpg move_right
    jump done_repeat

    label move_left
    move xmove -1
    jump done_repeat

    label move_right
    move xmove 1
    jump done_repeat

    label dec_tapped
    sub tapped 1
    label done_repeat

    call try_resolve_piece_movement curpiece currotation xpos ypos xmove ymove rotate
    ; reset rotation so it only happens once
    move rotate 0

    call check_timer elapsed PIECE_TIMER_ID
    cmp elapsed
    jumpz done_update
    move ymove ypos
    add  ymove 1

    ; repopulate because they may have changed
    call populate_piece_values curpiece currotation pos width height
    ; check to see if moving down would collide, and if so, plant the piece
    call check_collision collided xpos ymove pos width height
    cmp  collided
    jumpn plant_piece
    move ypos ymove
    jump done_update

    label plant_piece
        call update_pit_map curpiece currotation xpos ypos
        call update_pit_tilemaps_from_piece curpiece currotation xpos ypos
        ; signal piece reset
        move curpiece 0

    label done_update
        call check_timer elapsed BGSCROLL_TIMER_ID
        jumpz no_bgscroll
        ADVANCE_BGSCROLL bgscroll0:0 1  BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll0:1 -1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll1:0 1  BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll1:1 -1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll2:0 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll2:1 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll3:0 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll3:1 1 BACKGROUND_PATTERN_PXSIDE

        move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
        move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
        move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
        move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3
        label no_bgscroll
        move gfx_draw_layer window_background_layer_id
        move gfx_draw_layer window_pattern1_layer_id
        move gfx_draw_layer window_pattern0_layer_id
        call draw_pit
        move xmove xpos
        mul  xmove TILE_SIDE
        add  xmove pitxpos
        move ymove ypos
        mul  ymove TILE_SIDE
        add  ymove pitypos
        call draw_piece block_layer_id curpiece currotation xmove ymove

    label end
ret

proc event
    cmp event_get_type INPUT_TYPE_KEYDOWN
    jumpn keyup
    cmp event_get_button INPUT_KEY_f
    jumpz toggle_fullscreen
    cmp event_get_button INPUT_KEY_ESCAPE
    jumpz quit
    cmp event_get_button INPUT_KEY_a
    jumpz move_left
    cmp event_get_button INPUT_KEY_d
    jumpz move_right
    cmp event_get_button INPUT_KEY_q
    jumpz rotate_left
    cmp event_get_button INPUT_KEY_e
    jumpz rotate_right
    cmp event_get_button INPUT_KEY_s
    jumpz fall
    jump end

    label toggle_fullscreen
        call toggle_fullscreen
        call update_scale
    jump end

    label quit
        move set_running 0
    jump end

    label move_left
        move move -1
    jump end

    label move_right
        move move 1
    jump end

    label rotate_left
        move rotate -1
    jump end

    label rotate_right
        move rotate 1
    jump end

    label fall
        move fall 1
    jump end

    label keyup
    cmp event_get_type INPUT_TYPE_KEYUP
    jumpn end
    cmp event_get_button INPUT_KEY_a
    jumpz no_move_left
    cmp event_get_button INPUT_KEY_d
    jumpz no_move_right
    cmp event_get_button INPUT_KEY_s
    jumpz nofall
    jump end

    label no_move_left
        cmp move 0
        jumpg end
        move move 0
    jump end

    label no_move_right
        cmp move 0
        jumpl end
        move move 0
    jump end

    label nofall
        move fall 0
    jump end
 
    label end
ret
