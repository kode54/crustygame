include crustygame.inc
include fills.inc
include videomode.inc
include timers.inc
include text.inc
include objects.inc
include crustris_defs.inc

binclude gfx ints "crustris.crsg"
binclude font ints "font.crsg"
binclude title ints "crustris_logo.crsg"

macro CENTER RESULT SPACESIZE ITEMSIZE
    move RESULT SPACESIZE
    sub  RESULT ITEMSIZE
    div  RESULT 2
endmacro CENTER

proc populate_piece_values piece rotation pos width height
    local pieceptr

    ; copy values to locals to not mutate caller variables
    move pieceptr piece
    mul  pieceptr PIECEINFO_ROTATIONS
    add  pieceptr rotation

    move pos PIECEINFO_POS:pieceptr
    move width PIECEINFO_WIDTH:pieceptr
    move height PIECEINFO_HEIGHT:pieceptr
ret
 
proc rotate x y piece rotation dir
    local biasptr

    cmp dir 0
    jumpl rotate_ccw
    jumpg rotate_cw
    jump end

    label rotate_ccw
    sub rotation 1
    jumpg no_wrap_max
    jumpz no_wrap_max
    move rotation 3
    label no_wrap_max

    ; for counter clockwise, the pointer is the rotation transitioned to
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    ; for counter clockwise, the bias is subtracted (undone)
    sub x ROTATION_X_BIAS:biasptr
    sub y ROTATION_Y_BIAS:biasptr
    jump end

    label rotate_cw
    ; for clockwise, the pointer is the rotation transitioned from
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    add rotation 1
    cmp rotation 4
    jumpl no_wrap_0
    move rotation 0
    label no_wrap_0

    ; for clockwise, the bias is added
    add x ROTATION_X_BIAS:biasptr
    add y ROTATION_Y_BIAS:biasptr
    
    label end
ret

expr COLLIDED_LEFT   1
expr COLLIDED_RIGHT  2
expr COLLIDED_LEFT_RIGHT "COLLIDED_LEFT | COLLIDED_RIGHT"
expr COLLIDED_TOP    4
expr COLLIDED_BOTTOM 8
expr COLLIDED_TOP_BOTTOM "COLLIDED_TOP | COLLIDED_BOTTOM"

proc check_collision collided x y pos width height
    local piecex
    local piecey
    local pitx
    local pity
    local pitpos
    local piecepos
    local pieceval
    local halfwidth
    local halfheight
    local leftx
    local rightx
    local topy
    local bottomy

    move collided 0
    ; determine ranges where a collision is determined to be to a particular
    ; side. this could be made smaller but it wouldn't necessarily be faster
    ; and would be more difficult to understand when it's already janky
    move halfwidth width
    mod  halfwidth 2
    jumpz split_width
    ; odd number.  be greedy here and count the center piece outwards for both
    ; sides.  a bottom collision could result in both being flagged but that
    ; isn't important
    ; assume that integer divisions will be floored down
    move leftx width
    div  leftx 2
    move rightx leftx
    add  leftx 1
    jump find_halfheight
    label split_width
    move leftx width
    div  leftx 2
    move rightx leftx
    label find_halfheight
    move halfheight height
    mod  halfheight 2
    jumpz split_height
    ; as above
    move topy height
    div  topy 2
    move bottomy topy
    add  topy 1
    jump done_halves
    label split_height
    move topy height
    div  topy 2
    move bottomy topy
    label done_halves

    ; check collisions with pit boundaries
    ; check top
    cmp y 0
    jumpg check_pit_bottom
    jumpz check_pit_bottom
    or collided COLLIDED_TOP

    label check_pit_bottom
    move piecey y
    add  piecey height
    cmp  piecey PIT_HEIGHT
    jumpl check_pit_left
    jumpz check_pit_left
    or collided COLLIDED_BOTTOM

    label check_pit_left
    cmp x 0
    jumpg check_pit_right
    jumpz check_pit_right
    or collided COLLIDED_LEFT

    label check_pit_right
    move piecex x
    add  piecex width
    cmp  piecex PIT_WIDTH
    jumpl check_pit
    jumpz check_pit
    or collided COLLIDED_RIGHT

    label check_pit
    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    move piecepos pos
    move piecey 0
    move pity y
    label y
        cmp pity 0
        jumpl skip_y
        cmp pity PIT_HEIGHT
        jumpg end
        jumpz end

        move piecex 0
        move pitx x
        label x
            cmp pitx 0
            jumpl skip_x
            cmp pitx PIT_WIDTH
            jumpg skip_x
            jumpz skip_x

            move pieceval pieces:piecepos
            and  pieceval pit:pitpos
            jumpz no_collision

            ; determine what halves a collision happened on
            ; left side
            cmp piecex leftx
            jumpg check_right
            jumpz check_right
            or collided COLLIDED_LEFT
            label check_right
            cmp piecex rightx
            jumpl check_top
            or collided COLLIDED_RIGHT
            label check_top
            cmp piecey topy
            jumpg check_bottom
            jumpz check_bottom
            or collided COLLIDED_TOP
            label check_bottom
            cmp piecey bottomy
            jumpl no_collision
            or collided COLLIDED_BOTTOM
            label no_collision

            label skip_x
            add piecepos 1
            add pitpos 1
            add pitx 1
            add piecex 1
            cmp piecex width
        jumpl x

        sub pitpos width
        label skip_y
        add pitpos PIT_WIDTH
        add pity 1
        add piecey 1
        cmp piecey height
    jumpl y

    label end
ret

proc try_resolve_piece_movement piece rotation x y xmove ymove dir
    local pos
    local oldwidth
    local oldheight
    local width
    local height
    local xbias
    local ybias
    local newrotation
    local widthdiff
    local heightdiff
    local leftgrowth
    local rightgrowth
    local topgrowth
    local bottomgrowth
    local checkx
    local checky
    local collided
    local priority

    ; get the current and desired new piece stats
    call populate_piece_values piece rotation pos oldwidth oldheight
    move newrotation rotation
    call rotate xbias ybias piece newrotation dir
    call populate_piece_values piece newrotation pos width height

    ; try to do the full move
    move checkx x
    add  checkx xmove
    add  checkx xbias
    move checky y
    add  checky ymove
    add  checky ybias
    call check_collision priority checkx checky pos width height
    cmp priority
    jumpz update_all

    ; compare them to see if we need to check for left/right or up/down kicks,
    ; there can only be one or the other or neither for the O piece or if no
    ; rotation happened anyway
    move widthdiff width
    sub  widthdiff oldwidth
    move heightdiff height
    sub  heightdiff oldheight

    cmp widthdiff 0
    jumpg horz_kick
    cmp heightdiff 0
    jumpg vert_kick
    ; no rotation occurred or the piece doesn't occupy additional space so it
    ; doesn't need to kick, still update rotation anyway.
    move rotation newrotation
    jump no_kick

    label horz_kick
        ; piece is "jammed", don't try
        and priority COLLIDED_LEFT_RIGHT
        cmp priority COLLIDED_LEFT_RIGHT
        jumpz no_kick

        move leftgrowth widthdiff
        move rightgrowth widthdiff

        ; apply drop, if any, as well as bias
        move checky y
        add  checky ybias
        add  checky ymove

        ; try searching outwards up to the difference in width until a
        ; collision is found, if so, back off one and use that
        label horz_kick_loop
            cmp leftgrowth 0
            jumpg horz_loop_continue
            jumpz horz_loop_continue
            cmp rightgrowth 0
            jumpg horz_loop_continue
            jumpz horz_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump horz_loop_break
            label horz_loop_continue
                and priority COLLIDED_LEFT
                jumpn try_left

            label try_right
                cmp rightgrowth 0
                jumpl continue_right

                ; try moving right incrementally until a collision
                move checkx 0
                sub  checkx rightgrowth
                add  checkx x

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub rightgrowth 1
                cmp collided
                jumpz continue_right
                ; check to see if the collision happened on the right side
                and collided COLLIDED_RIGHT
                jumpz continue_right
                ; step back 1 and use that value
                sub checkx 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_right
                and priority COLLIDED_LEFT
                jumpn horz_kick_loop

            label try_left
                cmp leftgrowth 0
                jumpl continue_left

                ; same as above
                move checkx widthdiff
                mul  checkx -1
                add  checkx leftgrowth
                add  checkx x
                
                call check_collision collided checkx checky pos width height
                ; same as above
                sub leftgrowth 1
                cmp collided
                jumpz continue_left
                and collided COLLIDED_LEFT
                jumpz continue_left

                add checkx 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_left
                and priority COLLIDED_LEFT
                jumpn try_right
            jump horz_kick_loop

        label horz_loop_break
    jump no_kick

    label vert_kick
        ; piece is "jammed", don't try
        and priority COLLIDED_TOP_BOTTOM
        cmp priority COLLIDED_TOP_BOTTOM
        jumpz no_kick

        move topgrowth heightdiff
        move bottomgrowth heightdiff

        ; apply drop, if any, as well as bias
        move checkx x
        add  checkx xbias
        add  checkx xmove

        ; try searching outwards up to the difference in height until a
        ; collision is found, if so, back off one and use that
        label vert_kick_loop
            cmp topgrowth 0
            jumpg vert_loop_continue
            jumpz vert_loop_continue
            cmp bottomgrowth 0
            jumpg vert_loop_continue
            jumpz vert_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump vert_loop_break
            label vert_loop_continue
                and priority COLLIDED_TOP
                jumpn try_top

            label try_bottom
                cmp bottomgrowth 0
                jumpl continue_bottom

                ; try moving bottom incrementally until a collision
                move checky 0
                sub  checky bottomgrowth
                add  checky y

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub bottomgrowth 1
                cmp collided
                jumpz continue_bottom
                ; check to see if the collision happened on the bottom side
                and collided COLLIDED_BOTTOM
                jumpz continue_bottom
                ; step back 1 and use that value
                sub checky 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                ERR_NL collided
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_bottom
                and priority COLLIDED_TOP
                jumpn vert_kick_loop

            label try_top
                cmp topgrowth 0
                jumpl continue_top

                ; same as above
                move checky heightdiff
                mul  checky -1
                add  checky topgrowth
                add  checky y
                
                call check_collision collided checkx checky pos width height
                ; same as above
                sub topgrowth 1
                cmp collided
                jumpz continue_top
                and collided COLLIDED_TOP
                jumpz continue_top

                add checky 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_top
                and priority COLLIDED_TOP
                jumpn try_bottom
            jump vert_kick_loop

        label vert_loop_break
 
    label no_kick
        ; recalculate original position, width and height as they may have
        ; changed to a rotated state
        call populate_piece_values piece rotation pos width height

        ; try to move the piece in both requested directions
        move checkx x
        add  checkx xmove
        move checky y
        add  checky ymove
        call check_collision collided checkx checky pos width height
        cmp collided
        jumpz update_pos
        ; if either is 0, don't repeat an unnecessary test
        cmp xmove 0
        jumpz end
        cmp ymove 0
        jumpz end

        ; try to move the piece down only
        cmp ymove 0
        jumpz no_down_only
            move checkx x
            move checky y
            add  checky ymove
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
        label no_down_only

        ; try to move piece only laterally
        cmp xmove 0
        jumpz no_lateral_only
            move checkx x
            add  checkx xmove
            move checky y
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
        label no_lateral_only
    jump end

    label update_all
        move rotation newrotation
    label update_pos
        move x checkx
        move y checky
    label end
ret

proc update_pit_map piece rotation x y
    local piecex
    local pos
    local width
    local height
    local pitpos

    call populate_piece_values piece rotation pos width height

    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    label y
        move piecex width

        label x
            cmp pieces:pos
            jumpz no_update
                move pit:pitpos piece
            label no_update

            add pos 1
            add pitpos 1
            sub piecex 1
        jumpg x

        ; advance to the next row of the pit
        sub pitpos width
        add pitpos PIT_WIDTH
        sub height 1
    jumpg y
ret

proc update_pit_tilemaps x y w h
    local i
    local j
    local startptr
    local ptr
    local pitval

    move startptr y
    mul  startptr PIT_WIDTH
    add  startptr x

    move ptr startptr
    move j h
    label y
        move i w
        label x
            move pitval pit:ptr
            mul  pitval TILEMAP_WIDTH
            move pit_map0_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map0_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map1_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map1_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map2_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map2_colormod:ptr PIECE_COLORMOD:pitval
            sub  pitval 2

            add ptr 1
            sub i 1
        jumpg x
        sub ptr w
        add ptr PIT_WIDTH
        sub j 1
    jumpg y

    ; set tiles and attributes then update
    call gfx_set_tilemap_map3 pit_tilemap_id0 pit_map0_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id0 pit_map0_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id0 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id1 pit_map1_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id1 pit_map1_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id1 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id2 pit_map2_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id2 pit_map2_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id2 x y w h
ret

proc update_pit_tilemaps_from_piece piece rotation x y
    local pos
    local width
    local height

    call populate_piece_values piece rotation pos width height
    call update_pit_tilemaps x y width height
ret

proc drop_line line
    local block
    local curline
    local pitpos
    local abovepitpos

    move curline line

    ; start at the end of the line
    move pitpos line
    mul  pitpos PIT_WIDTH
    add  pitpos PIT_WIDTH
    sub  pitpos 1
    ; end of line above to copy from
    move abovepitpos pitpos
    sub  abovepitpos PIT_WIDTH

    label line
        move block PIT_WIDTH
        label block
            cmp abovepitpos 0
            jumpl set_zero
            move pit:pitpos pit:abovepitpos
            jump done_set
            label set_zero
            move pit:pitpos 0
            label done_set

            sub pitpos 1
            sub abovepitpos 1
            sub block 1
        jumpg block

        sub curline 1
    jumpg line
    jumpz line
ret

proc check_lines lines y height
    local pitpos
    local line
    local maxline
    local block
    local blocks

    move lines 0

    move maxline y
    add  maxline height

    move pitpos y
    mul  pitpos PIT_WIDTH

    move line y
    label line
        move block PIT_WIDTH
        move blocks 0
        label block
            cmp pit:pitpos
            jumpz noblock
            add blocks 1
            label noblock

            add pitpos 1
            sub block 1
        jumpg block
        cmp PIT_WIDTH blocks
        jumpg noclear
        call drop_line line
        add lines 1
        label noclear

        add line 1
        cmp line maxline
    jumpl line
ret

proc draw_pit
    move gfx_draw_layer pit_shadow_layer_id
    move gfx_draw_layer pit_pattern1_layer_id
    move gfx_draw_layer pit_pattern0_layer_id
    move gfx_draw_layer pit_background_layer_id
    move gfx_draw_layer pit_layer_id0
    move gfx_draw_layer pit_layer_id1
    move gfx_draw_layer pit_layer_id2
ret

proc draw_piece layer_id piece rotation x y
    local scaledx
    local scaledy
    local piecex
    local pos
    local width
    local height
    local window ints 2
    local position floats "0.0 0.0"
    local intPosition ints 2
    local scaled_tile floats 0.0

    call populate_piece_values piece rotation pos width height

    ; initial tilemap position
    move window:1 piece
    mul  window:1 TILE_SIDE 

    ; size of a tile in float which will be used to accumulate location
    move scaled_tile TILE_SIDE
    mul  scaled_tile objects_global_scale

    ; get the starting scaled position
    move scaledx x
    mul  scaledx objects_global_scale
    add  scaledx objects_global_offset:0
    move scaledy y
    mul  scaledy objects_global_scale
    add  scaledy objects_global_offset:1

    ; get initial y position
    move position:1 scaledy
 
    label y
        ; copy in to a storage useful by gfx
        move intPosition:1 position:1

        ; get initial x position
        move position:0 scaledx
        move piecex width
        label x
            cmp pieces:pos
            jumpz nodraw

            ; copy to an int to be useful by gfx
            move intPosition:0 position:0
            move gfx_set_layer_pos:layer_id intPosition
            move window:0 0
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            label nodraw

            ; advance table pointer
            add pos 1
            ; calculate next x position
            add position:0 scaled_tile
            sub piecex 1
        jumpg x

        ; calculate next y position
        add position:1 scaled_tile
        sub height 1
    jumpg y 
ret

static gfx_id
static font_id
static title_id
static block_tilemap_id
static block_layer_id
static pit_tilemap_id0
static pit_tilemap_id1
static pit_tilemap_id2
static pit_layer_id0
static pit_layer_id1
static pit_layer_id2
static pit_background_id
static pit_background_layer_id
static window_background_id
static window_background_layer_id
static window_pattern_id
static window_pattern0_layer_id
static window_pattern1_layer_id
static pit_shadow_id
static pit_shadow_layer_id
static pit_pattern_id
static pit_pattern0_layer_id
static pit_pattern1_layer_id
static labels_tilemap_id
static labels_layer0_id
static labels_layer1_id
static number_tilemap_id
static number_layer0_id
static number_layer1_id
static title_tilemap_id
static title_layer_id
static shade_layer_id
static characters_tilemap_id
static characters_layer_id

static block_obj
static pit0_obj
static pit1_obj
static pit2_obj
static pit_bg_obj
static win_bg_obj
static pit_sh_obj
static win_pat0_obj
static win_pat1_obj
static pit_pat0_obj
static pit_pat1_obj
static labels0_obj
static labels1_obj
static number0_obj
static number1_obj
static title_obj
static shade_obj
static characters_obj

static pitxpos
static pitypos

macro UPDATE_LEVEL
    move nextlines level
    add  nextlines 1
    mul  nextlines LINES_PER_LEVEL
    TIMERS_SET_RATE piece_timer_id LEVEL_CHANGE_RATES:level
    move gfx_set_layer_colormod:window_background_layer_id LEVEL_BG_COLOR:level
    move gfx_set_layer_colormod:pit_shadow_layer_id LEVEL_BG_SHADOW_COLOR:level
    move gfx_set_layer_colormod:labels_layer0_id LEVEL_BG_SHADOW_COLOR:level
    move gfx_set_layer_colormod:number_layer0_id LEVEL_BG_SHADOW_COLOR:level
endmacro UPDATE_LEVEL

static fps_timer_id
static piece_timer_id
static input_timer_id
static bgscroll_timer_id

proc init
    local temp ints 4
    local tempf floats "0.0 0.0 0.0 0.0"
    local pitbg ints PIT_BG_SIZE 
    local pitflags ints PIT_BG_SIZE 
    local pitcolormod ints PIT_BG_SIZE
    local row ints SCREEN_TILES_WIDTH
    local background_pattern ints BACKGROUND_SIZE

    call set_video_mode temp videomode
    cmp temp
    jumpn mode_ok
    move set_running 0
    jump end
    label mode_ok

    call timers_clear
    call objects_setup
    OBJECTS_SET_SCREEN_SIZE SCREEN_WIDTH SCREEN_HEIGHT

    move temp:0 gfx:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset gfx:CRSG_OFFSET_DATA gfx:CRSG_OFFSET_WIDTH gfx:CRSG_OFFSET_HEIGHT temp:0 TILE_SIDE TILE_SIDE gfx_id

    move temp:0 font:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset font:CRSG_OFFSET_DATA font:CRSG_OFFSET_WIDTH font:CRSG_OFFSET_HEIGHT temp:0 FONT_SIDE FONT_SIDE font_id

    ; single sprite
    move temp:0 title:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset title:CRSG_OFFSET_DATA title:CRSG_OFFSET_WIDTH title:CRSG_OFFSET_HEIGHT temp:0 title:CRSG_OFFSET_WIDTH title:CRSG_OFFSET_HEIGHT title_id

    call gfx_add_tilemap TILEMAP_WIDTH TILEMAP_HEIGHT block_tilemap_id
    move gfx_set_tilemap_tileset:block_tilemap_id gfx_id
    call gfx_set_tilemap_map block_tilemap_id PIECE_TILEMAP
    call gfx_set_tilemap_attr_colormod block_tilemap_id PIECE_COLORMOD
    call gfx_update_tilemap block_tilemap_id
    call gfx_add_layer block_tilemap_id block_layer_id
    call objects_get_free block_obj block_layer_id
    ; set some parameter otherwise it won't be updated right away
    OBJECTS_SET_SCALE block_obj 1 1
    move temp:0 TILE_SIDE
    move temp:1 TILE_SIDE
    move gfx_set_layer_window:block_layer_id temp
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_background_id
    move gfx_set_tilemap_tileset:pit_background_id gfx_id
    call gfx_add_layer pit_background_id pit_background_layer_id
    call objects_get_free pit_bg_obj pit_background_layer_id

    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id0
    move gfx_set_tilemap_tileset:pit_tilemap_id0 gfx_id
    call gfx_add_layer pit_tilemap_id0 pit_layer_id0
    call objects_get_free pit0_obj pit_layer_id0
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id1
    move gfx_set_tilemap_tileset:pit_tilemap_id1 gfx_id
    call gfx_add_layer pit_tilemap_id1 pit_layer_id1
    call objects_get_free pit1_obj pit_layer_id1
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id2
    move gfx_set_tilemap_tileset:pit_tilemap_id2 gfx_id
    call gfx_add_layer pit_tilemap_id2 pit_layer_id2
    call objects_get_free pit2_obj pit_layer_id2
  
    ; don't really care that pit* aren't static because the background is only
    ; set up once and it doesn't matter if the pointer becomes invalid.
    call fill_with_border pitbg PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_FILL PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER
    call gfx_set_tilemap_map pit_background_id pitbg
    call fill_with_border pitflags PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH 0 0 TILEMAP_HFLIP_MASK TILEMAP_ROTATE_90 0 TILEMAP_ROTATE_90 TILEMAP_VFLIP_MASK 0 TILEMAP_BFLIP_MASK
    call gfx_set_tilemap_attr_flags pit_background_id pitflags
    call fill_with_border pitcolormod PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH C_WHT C_WHT C_WHT C_WHT C_PIT_FILL C_WHT C_WHT C_WHT C_WHT
    call gfx_set_tilemap_attr_colormod pit_background_id pitcolormod
    call gfx_update_tilemap pit_background_id
    
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_shadow_id
    move gfx_set_tilemap_tileset:pit_shadow_id gfx_id
    call gfx_add_layer pit_shadow_id pit_shadow_layer_id
    call objects_get_free pit_sh_obj pit_shadow_id
    call fill row PIT_BG_WIDTH 1 PIT_BG_WIDTH SOLID_TILE
    call gfx_set_tilemap_map3 pit_shadow_id row 0 0 0 PIT_BG_WIDTH PIT_BG_HEIGHT
    call gfx_update_tilemap pit_shadow_id

    call gfx_add_tilemap SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT window_background_id
    move gfx_set_tilemap_tileset:window_background_id gfx_id
    call fill row SCREEN_TILES_WIDTH 1 SCREEN_TILES_WIDTH SOLID_TILE
    ; pitch = 0 so the same row is copied for each row
    call gfx_set_tilemap_map3 window_background_id row 0 0 0 SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT
    call gfx_update_tilemap window_background_id
    call gfx_add_layer window_background_id window_background_layer_id
    call objects_get_free win_bg_obj window_background_layer_id
    OBJECTS_SET_POS win_bg_obj 0 0
    call gfx_add_layer window_background_id shade_layer_id
    call objects_get_free shade_obj shade_layer_id
    OBJECTS_SET_SCALE shade_obj 1 1
    move gfx_set_layer_blendmode:shade_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:shade_layer_id C_BG_PATTERN_SHADOW

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap BACKGROUND_WIDTH BACKGROUND_HEIGHT window_pattern_id
    move gfx_set_tilemap_tileset:window_pattern_id gfx_id
    call gfx_set_tilemap_map window_pattern_id background_pattern
    call gfx_update_tilemap window_pattern_id
    call gfx_add_layer window_pattern_id window_pattern0_layer_id
    call gfx_add_layer window_pattern_id window_pattern1_layer_id
    move temp:0 SCREEN_TILES_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 SCREEN_TILES_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:window_pattern0_layer_id temp
    move gfx_set_layer_window:window_pattern1_layer_id temp
    move gfx_set_layer_blendmode:window_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:window_pattern1_layer_id C_BG_PATTERN_SHADOW
    call objects_get_free win_pat0_obj window_pattern0_layer_id
    OBJECTS_SET_POS win_pat0_obj 0 0
    call objects_get_free win_pat1_obj window_pattern1_layer_id
    OBJECTS_SET_POS win_pat1_obj 0 0

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN:BACKGROUND_PATTERN_SIZE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT pit_pattern_id
    move gfx_set_tilemap_tileset:pit_pattern_id gfx_id
    call gfx_set_tilemap_map3 pit_pattern_id background_pattern 0 0 BACKGROUND_WIDTH PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT
    call gfx_update_tilemap pit_pattern_id
    call gfx_add_layer pit_pattern_id pit_pattern0_layer_id
    call gfx_add_layer pit_pattern_id pit_pattern1_layer_id
    move temp:0 PIT_BG_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 PIT_BG_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:pit_pattern0_layer_id temp
    move gfx_set_layer_window:pit_pattern1_layer_id temp
    move gfx_set_layer_blendmode:pit_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:pit_pattern1_layer_id C_BG_PATTERN_SHADOW
    call objects_get_free pit_pat0_obj pit_pattern0_layer_id
    call objects_get_free pit_pat1_obj pit_pattern1_layer_id

    ; reuse background_pattern because it's a very large buffer
    call gfx_add_tilemap LABELS_TILEMAP_WIDTH LABELS_TILEMAP_HEIGHT labels_tilemap_id
    move gfx_set_tilemap_tileset:labels_tilemap_id font_id
    call text_string_to_tilemap background_pattern CONTROLS_TEXT_WIDTH CONTROLS_TEXT_HEIGHT LABELS_TILEMAP_WIDTH CONTROLS_TEXT
    move temp LABELS_TILEMAP_WIDTH
    mul  temp LINES_POS
    call text_string_to_tilemap background_pattern:temp LINES_TEXT: 1 LINES_TEXT: LINES_TEXT
    move temp LABELS_TILEMAP_WIDTH
    mul  temp LEVEL_POS
    call text_string_to_tilemap background_pattern:temp LEVEL_TEXT: 1 LEVEL_TEXT: LEVEL_TEXT
    move temp LABELS_TILEMAP_WIDTH
    mul  temp SCORE_POS
    call text_string_to_tilemap background_pattern:temp SCORE_TEXT: 1 SCORE_TEXT: SCORE_TEXT
    move temp LABELS_TILEMAP_WIDTH
    mul  temp NEXT_POS
    call text_string_to_tilemap background_pattern:temp NEXT_TEXT: 1 NEXT_TEXT: NEXT_TEXT
    call gfx_set_tilemap_map labels_tilemap_id background_pattern 
    call gfx_update_tilemap labels_tilemap_id
    call gfx_add_layer labels_tilemap_id labels_layer0_id
    call gfx_add_layer labels_tilemap_id labels_layer1_id
    move gfx_set_layer_blendmode:labels_layer1_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:labels_layer1_id C_BG_PATTERN_SHADOW
    call objects_get_free labels0_obj labels_layer0_id
    call objects_get_free labels1_obj labels_layer1_id
    OBJECTS_SET_SCALE labels0_obj FONT_SCALE FONT_SCALE
    OBJECTS_SET_SCALE labels1_obj FONT_SCALE FONT_SCALE

    call gfx_add_tilemap 128 1 characters_tilemap_id
    move gfx_set_tilemap_tileset:characters_tilemap_id font_id
    move temp 0
    label characters_fill
        cmp temp 128
        jumpz done_characters_fill
        move background_pattern:temp temp
        add temp 1
    jump characters_fill
    label done_characters_fill
    call gfx_set_tilemap_map characters_tilemap_id background_pattern
    call gfx_update_tilemap characters_tilemap_id
    call gfx_add_layer characters_tilemap_id characters_layer_id
    move temp:0 FONT_SIDE
    move temp:1 FONT_SIDE
    move gfx_set_layer_window:characters_layer_id temp
    call objects_get_free characters_obj characters_layer_id
    OBJECTS_SET_SCALE characters_obj FONT_SCALE FONT_SCALE

    call gfx_add_tilemap MAX_INTEGER_SIZE 1 number_tilemap_id
    move gfx_set_tilemap_tileset:number_tilemap_id font_id
    call gfx_add_layer number_tilemap_id number_layer0_id
    call gfx_add_layer number_tilemap_id number_layer1_id
    move gfx_set_layer_blendmode:number_layer1_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:number_layer1_id C_BG_PATTERN_SHADOW
    call objects_get_free number0_obj number_layer0_id
    call objects_get_free number1_obj number_layer1_id
    OBJECTS_SET_SCALE number0_obj FONT_SCALE FONT_SCALE
    OBJECTS_SET_SCALE number1_obj FONT_SCALE FONT_SCALE

    call gfx_add_tilemap 1 1 title_tilemap_id
    move gfx_set_tilemap_tileset:title_tilemap_id title_id
    move temp 0
    call gfx_set_tilemap_map title_tilemap_id temp
    call gfx_update_tilemap title_tilemap_id
    call gfx_add_layer title_tilemap_id title_layer_id
    call objects_get_free title_obj title_layer_id
    move tempf:1 title:CRSG_OFFSET_WIDTH
    mul  tempf:1 TITLE_SCALE
    CENTER tempf:0 SCREEN_WIDTH tempf:1
    OBJECTS_SET_POS_AND_SCALE title_obj tempf:0 tempf:0 TITLE_SCALE TITLE_SCALE

    ; center the pit
    CENTER tempf:0 SCREEN_WIDTH PIT_PXWIDTH
    CENTER tempf:1 SCREEN_HEIGHT PIT_PXHEIGHT
    move tempf:2 tempf:0
    move tempf:3 tempf:1
    sub  tempf:2 TILE_SIDE
    sub  tempf:3 TILE_SIDE
    move pitxpos tempf:0
    move pitypos tempf:1
    OBJECTS_SET_POS pit0_obj pitxpos pitypos
    OBJECTS_SET_POS pit1_obj pitxpos pitypos
    OBJECTS_SET_POS pit2_obj pitxpos pitypos
    move temp:0 tempf:2
    move temp:1 tempf:3
    OBJECTS_SET_POS pit_bg_obj temp:0 temp:1
    OBJECTS_SET_POS pit_sh_obj pitxpos pitypos
    OBJECTS_SET_POS pit_pat0_obj pitxpos pitypos
    OBJECTS_SET_POS pit_pat1_obj pitxpos pitypos

    call timers_get_free fps_timer_id 1000
    ; not ready to get this one going yet but just get the ID
    call timers_get_free piece_timer_id 0
    call timers_get_free input_timer_id INPUT_DELAY
    call timers_get_free bgscroll_timer_id BGSCROLL_DELAY

    move bgscroll0:0 0
    move bgscroll0:1 0
    move bgscroll1:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:0 1
    move bgscroll1:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:1 1
    move bgscroll2:0 0
    move bgscroll2:1 0
    move bgscroll3:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:0 1
    move bgscroll3:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:1 1
    move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
    move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
    move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
    move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3

    ; will be called anyway later, but the background and some initial things
    ; need to be set up first
    call setup_game
    label end
ret

static fps

proc count_fps
    local elapsed

    call timers_check elapsed fps_timer_id
    cmp elapsed
    jumpz fps_continue
    move err fps
    move err NL
    move fps 0

    label fps_continue
    add fps 1
ret

proc pit_effect
    local piece
    local rotation
    local width
    local height
    local pos
    local maxx
    local maxy
    local x
    local y

    move piece get_random
    mod  piece PIECEINFO_PIECES
    add  piece 1
    move rotation get_random
    mod  rotation PIECEINFO_ROTATIONS

    call populate_piece_values piece rotation pos width height

    move maxx PIT_WIDTH
    sub  maxx width
    add  maxx 1
    move maxy PIT_HEIGHT
    sub  maxy height
    add  maxy 1
    move x get_random
    mod  x maxx
    move y get_random
    mod  y maxy

    call update_pit_map piece rotation x y
    call update_pit_tilemaps_from_piece piece rotation x y
ret

macro ADVANCE_BGSCROLL VAR DIR MAX
    add VAR DIR
    cmp VAR MAX
    jumpz wrap_VAR_0
    cmp VAR 0
    jumpl wrap_VAR_max
    jump wrap_VAR_done
    label wrap_VAR_0
    move VAR 0
    jump wrap_VAR_done
    label wrap_VAR_max
    move VAR MAX
    sub  VAR 1
    label wrap_VAR_done
endmacro ADVANCE_BGSCROLL

macro DRAW_LABEL LPOS WIDTH HEIGHT SCREENPOS
    move temp:0 WIDTH
    mul  temp:0 FONT_SIDE
    move temp:1 HEIGHT
    mul  temp:1 FONT_SIDE
    move gfx_set_layer_window:labels_layer0_id temp
    move gfx_set_layer_window:labels_layer1_id temp
    move temp:0 0
    move temp:1 LPOS
    mul  temp:1 FONT_SIDE
    move gfx_set_layer_scroll_pos:labels_layer0_id temp
    move gfx_set_layer_scroll_pos:labels_layer1_id temp
    move temp:0 FONT_SIDE
    move temp:1 SCREENPOS
    mul  temp:1 FONT_SCALED_SIDE
    add  temp:1 FONT_SIDE
    OBJECTS_SET_POS labels0_obj temp:0 temp:1
    add  temp:0 1
    add  temp:1 1
    OBJECTS_SET_POS labels1_obj temp:0 temp:1
    move gfx_draw_layer labels_layer1_id
    move gfx_draw_layer labels_layer0_id
endmacro DRAW_LABEL

macro DRAW_NUMBER NUM SCREENPOS
    call text_integer_to_string numlen tempnum NUM
    call text_string_to_tilemap tempnummap numlen 1 MAX_INTEGER_SIZE tempnum
    call gfx_set_tilemap_map3 number_tilemap_id tempnummap 0 0 numlen numlen 1
    call gfx_update_tilemap2 number_tilemap_id 0 0 numlen 1
    move temp:0 numlen
    mul  temp:0 FONT_SIDE
    move temp:1 FONT_SIDE
    move gfx_set_layer_window:number_layer0_id temp
    move gfx_set_layer_window:number_layer1_id temp
    move temp SCREENPOS
    mul  temp FONT_SCALED_SIDE
    add  temp FONT_SIDE
    OBJECTS_SET_POS number0_obj FONT_SIDE temp
    add temp:0 1
    add temp:1 1
    OBJECTS_SET_POS number1_obj FONT_SIDE temp
    move gfx_draw_layer number_layer1_id
    move gfx_draw_layer number_layer0_id
endmacro DRAW_NUMBER

static bgscroll0 ints 2
static bgscroll1 ints 2
static bgscroll2 ints 2
static bgscroll3 ints 2
expr TEXT_ANIM_AMP 6
static text_anim_dir 1
static text_anim_start 0

proc text_anim_next start dir
    local temp

    move temp TEXT_ANIM_AMP
    mul  temp dir
    cmp  start temp
    jumpz text_anim_reverse
    jump no_text_anim_reverse
    label text_anim_reverse
    mul  dir -1
    label no_text_anim_reverse
    add  start dir
ret

proc draw_screen
    local elapsed

    call timers_check elapsed bgscroll_timer_id
    cmp elapsed
    jumpz no_bgscroll
    ADVANCE_BGSCROLL bgscroll0:0 1  BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll0:1 -1 BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll1:0 1  BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll1:1 -1 BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll2:0 1 BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll2:1 1 BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll3:0 1 BACKGROUND_PATTERN_PXSIDE
    ADVANCE_BGSCROLL bgscroll3:1 1 BACKGROUND_PATTERN_PXSIDE

    call text_anim_next text_anim_start text_anim_dir

    move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
    move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
    move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
    move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3
    label no_bgscroll
    move gfx_draw_layer window_background_layer_id
    move gfx_draw_layer window_pattern1_layer_id
    move gfx_draw_layer window_pattern0_layer_id
    call draw_pit
ret

proc draw_shade x y w h
    local temp ints 2

    OBJECTS_SET_POS shade_obj x y
    move temp:0 w
    move temp:1 h
    move gfx_set_layer_window:shade_layer_id temp
    move gfx_draw_layer shade_layer_id
ret

proc draw_text obj x y width height string animated
    local temp ints 2
    local stringpos 0
    local xpos 0
    local ypos
    local no_advance
    local layer_id
    local wordstart
    local wordlen
    local remain
    local anim_offset
    local anim_offset_dir

    move anim_offset text_anim_start
    move anim_offset_dir text_anim_dir

    OBJECTS_GET_LAYER_ID layer_id obj

    move ypos FONT_SCALED_SIDE
    label do_word
        move no_advance 0
        ; eat any leading spaces or newlines
        label eat_whitespace
            cmp stringpos string:
            jumpz end

            cmp string:stringpos SPC
            jumpz eat_space
            cmp string:stringpos NL
            jumpz eat_newline
        jump done_eat_whitespace
        label eat_space
            cmp no_advance
            jumpn eat_whitespace

            add xpos FONT_SCALED_SIDE
            cmp xpos width
            jumpl no_wrap
                add ypos FONT_SCALED_SIDE
                cmp ypos height
                jumpg end
                jumpz end

                move no_advance 1
                move xpos 0
            label no_wrap

            add stringpos 1
        jump eat_whitespace
        label eat_newline
            add ypos FONT_SCALED_SIDE
            cmp ypos height
            jumpz end

            move no_advance 0
            move xpos 0
            add stringpos 1
        jump eat_whitespace
        label done_eat_whitespace

        ; find the length of the word that needs to be copied
        move wordstart stringpos
        label find_wordend
            cmp string:stringpos SPC
            jumpz found_wordend
            cmp string:stringpos NL
            jumpz found_wordend
            ; this one is special because the procedure shouldn't just quit at
            ; the end of the string, but consider this the end of the word
            add stringpos 1
            cmp stringpos string:
            jumpz found_wordend
        jump find_wordend
        label found_wordend

        ; if the word doesn't fit and tilemapx is 0, just copy the word
        ; character by character advancing the character each time. if tilemapx
        ; isn't 0, jump to the next line then try the check again. if it still
        ; doesn't fit, it'll just revert to fully copying.

        move wordlen stringpos
        ; reset the string position to the start of the word after it's done
        ; with the value
        move stringpos wordstart
        sub  wordlen wordstart
        label retry_word
        move remain width
        sub  remain xpos
        div  remain FONT_SCALED_SIDE
        cmp  wordlen remain
        jumpg try_new_line

        label copy_word
            move temp:0 string:stringpos
            mul  temp:0 FONT_SIDE
            move temp:1 0
            move gfx_set_layer_scroll_pos:layer_id temp
            move temp:0 xpos
            add  temp:0 x
            move temp:1 ypos
            add  temp:1 y
            sub  temp:1 FONT_SCALED_SIDE
            cmp animated
            jumpz no_animation
                add temp:1 anim_offset
                call text_anim_next anim_offset anim_offset_dir
            label no_animation
            OBJECTS_SET_POS obj temp:0 temp:1
            move gfx_draw_layer layer_id

            add xpos FONT_SCALED_SIDE
            cmp xpos width
            jumpl no_wrap2
                add ypos FONT_SCALED_SIDE
                cmp ypos height
                jumpg end
                jumpz end

                move xpos 0
            label no_wrap2

            add stringpos 1
            sub wordlen 1
        jumpg copy_word
        jump do_word_continue

        label try_new_line
            cmp remain width
            jumpz copy_line
            add ypos FONT_SCALED_SIDE
            cmp ypos height
            jumpg end
            jumpz end
            move xpos 0
            jump retry_word

        label copy_line
            move temp:0 string:stringpos
            mul  temp:0 FONT_SIDE
            move temp:1 0
            move gfx_set_layer_scroll_pos:layer_id temp
            move temp:0 xpos
            add  temp:0 x
            move temp:1 ypos
            add  temp:1 y
            OBJECTS_SET_POS obj temp:0 temp:1
            move gfx_draw_layer layer_id

            add xpos FONT_SCALED_SIDE
            cmp xpos width
            jumpl no_wrap3
                add ypos FONT_SCALED_SIDE
                cmp ypos height
                jumpg end
                jumpz end

                move xpos 0
            label no_wrap3

            add stringpos 1
            sub remain 1
        jumpg copy_line

        label do_word_continue
    jumpz do_word
    label end
ret

static level
static nextpiece
static curpiece
static currotation
static xpos
static ypos
static lastmove
static move
static tapped
static fall
static rotate
static lines_cleared
static nextlines
static score

expr GAME_MODE_PLAYING 0
expr GAME_MODE_ENDED   1
expr GAME_MODE_TITLE   2

static game_mode GAME_MODE_TITLE

proc do_title_frame
    local temp ints 4
    local textw
    local textx
    local texty
    local shadew
    local shadeh
    local shadex
    local shadey
    local titlew
    local titlex

    call pit_effect
    call draw_screen
    call draw_shade 0 0 SCREEN_WIDTH SCREEN_HEIGHT
    move gfx_draw_layer title_layer_id

    move textw PRESS_ENTER_TEXT:
    move shadew textw
    add  shadew 2
    mul  textw FONT_SCALED_SIDE
    mul  shadew FONT_SCALED_SIDE
    move shadeh FONT_SCALED_SIDE
    mul  shadeh 3
    CENTER shadex SCREEN_WIDTH shadew
    move textx shadex
    add  textx FONT_SCALED_SIDE
    move titlew title:CRSG_OFFSET_WIDTH
    mul  titlew TITLE_SCALE
    CENTER titlex SCREEN_WIDTH titlew
    move shadey SCREEN_HEIGHT
    sub  shadey titlex
    sub  shadey shadeh
    move texty shadey
    add  texty FONT_SCALED_SIDE

    call draw_shade shadex shadey shadew shadeh
    call draw_text characters_obj textx texty textw FONT_SCALED_SIDE PRESS_ENTER_TEXT 1
ret

proc do_game_frame
    local curTick
    local width
    local height
    local pos
    local elapsed
    local xmove
    local ymove
    local collided
    local lines
    local temp ints 2
    local tempnum string "           "
    local tempnummap ints MAX_INTEGER_SIZE
    local numlen

    cmp curpiece
    jumpn have_piece
        move curpiece nextpiece
        move nextpiece get_random
        mod  nextpiece PIECEINFO_PIECES
        add  nextpiece 1
        move currotation 0
        move ypos 0
        call populate_piece_values curpiece currotation pos width height
        move xpos PIT_WIDTH
        sub  xpos width
        div  xpos 2

        call check_collision collided xpos ymove pos width height
        cmp collided
        jumpz have_piece
        move game_mode GAME_MODE_ENDED
        call update_pit_map curpiece currotation xpos ypos
        call update_pit_tilemaps_from_piece curpiece currotation xpos ypos
        jump done_update
    label have_piece

    ; nothing to do if lastmove and move are equal since there's no state to
    ; transition to
    cmp lastmove move
    jumpz done_tap

    cmp move 0
    jumpl tap_left
    jumpg tap_right
    ; transition to 0, rearm to allow more tapping.
    move lastmove 0
    jump done_tap

    label tap_left
    cmp move lastmove
    jumpz done_tap
    ; transition to left, move left and set lastmove to move to make sure a
    ; tap isn't signaled until lastmove has been reset back to 0 if the user
    ; has indicated to stop.  initialize tapped to allow a delay before the
    ; motion repeats.
    move xmove -1
    move lastmove move
    move tapped TAP_DELAY
    jump done_tap

    label tap_right
    cmp move lastmove
    jumpz done_tap
    ; same as above
    move xmove 1
    move lastmove move
    move tapped TAP_DELAY
    label done_tap

    call timers_check elapsed input_timer_id
    cmp elapsed
    jumpz done_repeat

    cmp fall
    jumpz no_fall
    move ymove 1
    label no_fall

    ; the timer has elapsed, check to see if lastmove and move are equal,
    ; tapped is 0 (and if not, decrease it), then figure out what to do with
    ; move
    cmp move lastmove
    jumpn done_repeat
    cmp tapped 0
    jumpn dec_tapped
    cmp move 0
    jumpl move_left
    jumpg move_right
    jump done_repeat

    label move_left
    move xmove -1
    jump done_repeat

    label move_right
    move xmove 1
    jump done_repeat

    label dec_tapped
    sub tapped 1
    label done_repeat

    call try_resolve_piece_movement curpiece currotation xpos ypos xmove ymove rotate
    ; reset rotation so it only happens once
    move rotate 0

    call timers_check elapsed piece_timer_id
    cmp elapsed
    jumpz done_update
    move ymove ypos
    add  ymove DEBUG_DO_PIECE_FALL

    ; repopulate because they may have changed
    call populate_piece_values curpiece currotation pos width height
    ; check to see if moving down would collide, and if so, plant the piece
    call check_collision collided xpos ymove pos width height
    cmp  collided
    jumpn plant_piece
    move ypos ymove
    jump done_update

    label plant_piece
        call update_pit_map curpiece currotation xpos ypos
        call check_lines lines ypos height
        cmp lines
        jumpg update_pit_lines
        call update_pit_tilemaps_from_piece curpiece currotation xpos ypos
        jump done_pit_updates
        label update_pit_lines
        add lines_cleared lines
        move temp level
        add  temp 1
        mul  temp LINES_SCORE_SCALE:lines
        add  score temp
        cmp lines_cleared nextlines
        jumpl no_next_level
        cmp level MAX_LEVEL
        jumpz no_next_level
        add level 1
        UPDATE_LEVEL
        label no_next_level
        ; update the pit up to the line the piece fell to
        add height ypos
        call update_pit_tilemaps 0 0 PIT_WIDTH height
        label done_pit_updates
        ; signal piece reset
        move curpiece 0

    label done_update
        call draw_screen

        DRAW_LABEL CONTROLS_TEXT_POS CONTROLS_TEXT_WIDTH CONTROLS_TEXT_HEIGHT CONTROLS_TEXT_SCREEN_POS
        DRAW_LABEL LINES_POS LINES_TEXT: 1 LINES_SCREEN_POS
        DRAW_NUMBER lines_cleared LINES_NUM_SCREEN_POS
        DRAW_LABEL LEVEL_POS LEVEL_TEXT: 1 LEVEL_SCREEN_POS
        DRAW_NUMBER level LEVEL_NUM_SCREEN_POS
        DRAW_LABEL SCORE_POS SCORE_TEXT: 1 SCORE_SCREEN_POS
        DRAW_NUMBER score SCORE_NUM_SCREEN_POS
        DRAW_LABEL NEXT_POS NEXT_TEXT: 1 NEXT_SCREEN_POS

        move xmove xpos
        mul  xmove TILE_SIDE
        add  xmove pitxpos
        move ymove ypos
        mul  ymove TILE_SIDE
        add  ymove pitypos
        call draw_piece block_layer_id curpiece currotation xmove ymove
        call draw_piece block_layer_id nextpiece 0 FONT_SIDE NEXT_PIECE_POS
ret

proc do_gameover_frame
    call draw_screen
ret

proc frame
    local junk

    cmp game_mode GAME_MODE_TITLE
    jumpz do_title
    cmp game_mode GAME_MODE_PLAYING
    jumpz do_game
    cmp game_mode GAME_MODE_ENDED
    jumpz do_gameover
    jump end
    label do_title
        call do_title_frame
    jump end
    label do_game
        call do_game_frame
    jump end
    label do_gameover
        call do_gameover_frame
    label end

    ; always do random
    move junk get_random
;    call count_fps
ret

proc setup_game
    local i

    ; reset variables
    move level STARTING_LEVEL
    move curpiece DEBUG_START_PIECE
    move lastmove 0
    move move 0
    move tapped 0
    move fall 0
    move rotate 0
    move lines_cleared 0
    move score 0
    move nextpiece get_random
    mod  nextpiece PIECEINFO_PIECES
    add  nextpiece 1
 
    ; clear the pit
    move i PIT_SIZE
    label clear_pit
        sub i 1
        jumpl done_clear_pit
        move pit:i 0
    jump clear_pit
    label done_clear_pit    
    
    ; update the whole pit
    call update_pit_tilemaps 0 0 PIT_WIDTH PIT_HEIGHT

    UPDATE_LEVEL
ret

proc generic_event keycode
    cmp event_get_button INPUT_KEY_f
    jumpz toggle_fullscreen
    cmp event_get_button INPUT_KEY_ESCAPE
    jumpz quit
    jump end

    label toggle_fullscreen
        call toggle_fullscreen
        call objects_update_global_scale
        call objects_update_scales
        move keycode -1
    jump end

    label quit
        move set_running 0
        move keycode -1
    label end
ret

proc do_title_event
    local button

    cmp event_get_type INPUT_TYPE_KEYDOWN
    jumpn end
    move button event_get_button
    call generic_event button
    cmp button
    jumpl end

    cmp button INPUT_KEY_RETURN
    jumpz start_game
    jump end

    label start_game
        ; TODO look in to flicker when transitioning from title to game
        call setup_game
        move game_mode GAME_MODE_PLAYING
    jump end

    label end
ret

proc do_game_event
    local button

    cmp event_get_type INPUT_TYPE_KEYDOWN
    jumpn keyup
    move button event_get_button
    call generic_event button
    cmp button
    jumpl end

    cmp button INPUT_KEY_a
    jumpz move_left
    cmp button INPUT_KEY_d
    jumpz move_right
    cmp button INPUT_KEY_q
    jumpz rotate_left
    cmp button INPUT_KEY_e
    jumpz rotate_right
    cmp button INPUT_KEY_s
    jumpz fall
    jump end

    label move_left
        move move -1
    jump end

    label move_right
        move move 1
    jump end

    label rotate_left
        move rotate -1
    jump end

    label rotate_right
        move rotate 1
    jump end

    label fall
        move fall 1
    jump end

    label keyup
    cmp event_get_type INPUT_TYPE_KEYUP
    jumpn end
    cmp event_get_button INPUT_KEY_a
    jumpz no_move_left
    cmp event_get_button INPUT_KEY_d
    jumpz no_move_right
    cmp event_get_button INPUT_KEY_s
    jumpz nofall
    jump end

    label no_move_left
        cmp move 0
        jumpg end
        move move 0
    jump end

    label no_move_right
        cmp move 0
        jumpl end
        move move 0
    jump end

    label nofall
        move fall 0
    jump end
 
    label end
ret

proc do_gameover_event
    local button

    cmp event_get_type INPUT_TYPE_KEYDOWN
    jumpn end
    move button event_get_button
    call generic_event button

    label end
ret

proc event
    cmp game_mode GAME_MODE_TITLE
    jumpz do_title
    cmp game_mode GAME_MODE_PLAYING
    jumpz do_game
    cmp game_mode GAME_MODE_ENDED
    jumpz do_gameover
    jump end
    label do_title
        call do_title_event
    jump end
    label do_game
        call do_game_event
    jump end
    label do_gameover
        call do_gameover_event
    label end
ret
