include crustygame.inc
include fills.inc
include videomode.inc
include timers.inc
include text.inc
include objects.inc

binclude gfx ints "crustris.crsg"
binclude font ints "font.crsg"

expr STARTING_LEVEL 1
expr LINES_PER_LEVEL 10
expr MAX_LEVEL 20
static LEVEL_CHANGE_RATES ints "\
    1000 950 900 850 800 750 700 650 600 550 \
     500 450 400 350 300 250 200 150 100  50"

TILEMAP_COLOR BG_L1    244 169 213 255
TILEMAP_COLOR BG_D_L1   27  80 173 255 
TILEMAP_COLOR BG_L2    230 227  74 255
TILEMAP_COLOR BG_D_L2   63 136  88 255 
TILEMAP_COLOR BG_L3    139 157  84 255
TILEMAP_COLOR BG_D_L3  124  87  39 255 
TILEMAP_COLOR BG_L4     80 202 255 255
TILEMAP_COLOR BG_D_L4   74   5 121 255 
TILEMAP_COLOR BG_L5    181 224 213 255
TILEMAP_COLOR BG_D_L5  104 102  85 255 
TILEMAP_COLOR BG_L6    212 209 180 255
TILEMAP_COLOR BG_D_L6   69  71  63 255 
TILEMAP_COLOR BG_L7     94 184 209 255
TILEMAP_COLOR BG_D_L7   83 144  29 255 
TILEMAP_COLOR BG_L8    121 250  97 255
TILEMAP_COLOR BG_D_L8  182 199   8 255 
TILEMAP_COLOR BG_L9    239 233 120 255
TILEMAP_COLOR BG_D_L9   74 115  13 255 
TILEMAP_COLOR BG_L10    79 200  39 255
TILEMAP_COLOR BG_D_L10  15  86  70 255 
TILEMAP_COLOR BG_L11    94 190 186 255
TILEMAP_COLOR BG_D_L11   0  81 117 255 
TILEMAP_COLOR BG_L12   205 221 253 255
TILEMAP_COLOR BG_D_L12   1  14  49 255 
TILEMAP_COLOR BG_L13   106 150 242 255
TILEMAP_COLOR BG_D_L13 192 205 221 255 
TILEMAP_COLOR BG_L14   204  92 215 255
TILEMAP_COLOR BG_D_L14 155  18  91 255 
TILEMAP_COLOR BG_L15    49 181 148 255
TILEMAP_COLOR BG_D_L15  67 112  31 255 
TILEMAP_COLOR BG_L16    32 113   0 255
TILEMAP_COLOR BG_D_L16  70  59  31 255 
TILEMAP_COLOR BG_L17    89  85  58 255
TILEMAP_COLOR BG_D_L17  66  29  10 255 
TILEMAP_COLOR BG_L18    38  28  20 255
TILEMAP_COLOR BG_D_L18 111  20   0 255 
TILEMAP_COLOR BG_L19   255   0   0 255
TILEMAP_COLOR BG_D_L19   0   0   0 255 
TILEMAP_COLOR BG_L20     0   0   0 255
TILEMAP_COLOR BG_D_L20 255 255 255 255 

expr INPUT_DELAY 50
expr TAP_DELAY 2
TILEMAP_COLOR BG_PATTERN_SHADOW 255 255 255 64
expr BGSCROLL_DELAY "1000 / 60"
; 0 for normal
expr DEBUG_START_PIECE 0
; 1 for normal
expr DEBUG_DO_PIECE_FALL 1

static LEVEL_BG_COLOR ints "\
    C_BG_L1  C_BG_L2  C_BG_L3  C_BG_L4  C_BG_L5  \
    C_BG_L6  C_BG_L7  C_BG_L8  C_BG_L9  C_BG_L10 \
    C_BG_L11 C_BG_L12 C_BG_L13 C_BG_L14 C_BG_L15 \
    C_BG_L16 C_BG_L17 C_BG_L18 C_BG_L19 C_BG_L20"

static LEVEL_BG_SHADOW_COLOR ints "\
    C_BG_D_L1  C_BG_D_L2  C_BG_D_L3  C_BG_D_L4  C_BG_D_L5  \
    C_BG_D_L6  C_BG_D_L7  C_BG_D_L8  C_BG_D_L9  C_BG_D_L10 \
    C_BG_D_L11 C_BG_D_L12 C_BG_D_L13 C_BG_D_L14 C_BG_D_L15 \
    C_BG_D_L16 C_BG_D_L17 C_BG_D_L18 C_BG_D_L19 C_BG_D_L20"

macro SET_VIDEO_MODE
    static videomode string VIDEOMODE
    expr VIDEO_MODE_SET 1
endmacro SET_VIDEO_MODE

macro SET_DEFAULT_VIDEO_MODE
    static videomode string "640x480"
endmacro SET_DEFAULT_VIDEO_MODE

if VIDEOMODE SET_VIDEO_MODE
expr VIDEO_MODE_NOT_SET "VIDEO_MODE_SET ^ 1"
if VIDEO_MODE_NOT_SET SET_DEFAULT_VIDEO_MODE

expr TILE_SIDE 16

expr SCREEN_WIDTH 640
expr SCREEN_HEIGHT 480
expr SCREEN_TILES_WIDTH "SCREEN_WIDTH / TILE_SIDE"
expr SCREEN_TILES_HEIGHT "SCREEN_HEIGHT / TILE_SIDE"

expr GAME_MODE_PLAYING 0
expr GAME_MODE_ENDED   1

static game_mode GAME_MODE_PLAYING

expr FONT_SIDE 8

static CONTROLS_TEXT string "\
CONTROLS:
Q - Rotate Counter Clockwise
E - Rotate Clockwise
A - Move Left
S - Move Down
D - Move Up"
expr CONTROLS_TILEMAP_WIDTH  15
expr CONTROLS_TILEMAP_HEIGHT 9
expr CONTROLS_TILEMAP_SIZE   "CONTROLS_TILEMAP_WIDTH * CONTROLS_TILEMAP_HEIGHT" 
static controls_tilemap ints CONTROLS_TILEMAP_SIZE

; assure collision masking works.
static pieces ints "\
255 255 255 \
0   255 0 \
0   255 \
255 255 \
0   255 \
0   255 0 \
255 255 255 \
255 0 \
255 255 \
255 0 \
\
255 255 255 \
0   0   255 \
0   255 \
0   255 \
255 255 \
255 0   0 \
255 255 255 \
255 255 \
255 0 \
255 0 \
\
255 255 0 \
0   255 255 \
0   255 \
255 255 \
255 0 \
\
255 255 \
255 255 \
\
0   255 255 \
255 255 0 \
255 0 \
255 255 \
0   255 \
\
255 255 255 \
255 0   0 \
255 255 \
0   255 \
0   255 \
0   0   255 \
255 255 255 \
255 0 \
255 0 \
255 255 \
\
255 \
255 \
255 \
255 \
255 255 255 255"
; all arrays refering to pieces have a null 0th index since 0 means no piece
; and pieces index starting at 1
expr PIECEINFO_PIECES    7
expr PIECEINFO_ROTATIONS 4
static PIECEINFO_POS ints "\
      0   0   0   0 \
      0   6  12  18 \
     24  30  36  42 \
     48  54  48  54 \
     60  60  60  60 \
     64  70  64  70 \
     76  82  88  94 \
    100 104 100 104"
static PIECEINFO_WIDTH ints "\
    0 0 0 0 \
    3 2 3 2 \
    3 2 3 2 \
    3 2 3 2 \
    2 2 2 2 \
    3 2 3 2 \
    3 2 3 2 \
    1 4 1 4"
static PIECEINFO_HEIGHT ints "\
    0 0 0 0 \
    2 3 2 3 \
    2 3 2 3 \
    2 3 2 3 \
    2 2 2 2 \
    2 3 2 3 \
    2 3 2 3 \
    4 1 4 1"
; left side is starting at transition from rotation 0 to rotation 1 then the
; far right column is the transition from rotation 3 back to 0.
; that is, the rotation transitioned from is the column that should be read
; from.
; for counter-clockwise rotation, the column for the rotation transitioned to
; should be read, then negated.
static ROTATION_X_BIAS ints "\
     0  0  0  0 \
     0  0  1 -1 \
     0  0  1 -1 \
     1 -1  0  0 \
     0  0  0  0 \
     1 -1  0  0 \
     0  0  1 -1 \
    -2  1 -1  2"
static ROTATION_Y_BIAS ints "\
     0  0  0  0 \
    -1  0  0  1 \
    -1  0  0  1 \
     0  1 -1  0 \
     0  0  0  0 \
     0  1 -1  0 \
    -1  0  0  1 \
     2 -2  1 -1"

expr PIT_WIDTH 10
expr PIT_HEIGHT 20
expr PIT_SIZE "PIT_WIDTH * PIT_HEIGHT"
static pit ints PIT_SIZE
static pit_map0_tiles ints PIT_SIZE
static pit_map1_tiles ints PIT_SIZE
static pit_map2_tiles ints PIT_SIZE
static pit_map0_colormod ints PIT_SIZE
static pit_map1_colormod ints PIT_SIZE
static pit_map2_colormod ints PIT_SIZE
expr PIT_BG_WIDTH  "PIT_WIDTH + 2"
expr PIT_BG_HEIGHT "PIT_HEIGHT + 2"
expr PIT_BG_SIZE   "PIT_BG_WIDTH * PIT_BG_HEIGHT"
expr PIT_TILE_CORNER 4
expr PIT_TILE_EDGE   5
expr PIT_TILE_FILL   3
; C_PIT_FILL
TILEMAP_COLOR PIT_FILL 160 160 160 127
expr CLEAR_TILE      1
expr SOLID_TILE      0
expr BACKGROUND_TILE 2

static PIECE_TILEMAP ints "CLEAR_TILE CLEAR_TILE CLEAR_TILE 0 \
                           0  6  7 0 \
                           0  8  9 0 \
                           0 10 11 0 \
                           0 12 13 0 \
                           0 14 15 0 \
                           0 16 17 0 \
                           0 18 19 0"
; Probably should be power of two
static TILEMAP_WIDTH 4
static TILEMAP_HEIGHT 8
TILEMAP_COLOR BLK   0   0   0 255
TILEMAP_COLOR CYA   0 170 170 255
TILEMAP_COLOR YEL 170 170   0 255
TILEMAP_COLOR PUR 170   0 170 255
TILEMAP_COLOR GRN   0 170   0 255
TILEMAP_COLOR RED 170   0   0 255
TILEMAP_COLOR BLU   0   0 170 255
TILEMAP_COLOR ORA 170  85   0 255
TILEMAP_COLOR LCY  85 255 255 255
TILEMAP_COLOR LYE 255 255  85 255
TILEMAP_COLOR LPU 255  85 255 255
TILEMAP_COLOR LGR  85 255  85 255
TILEMAP_COLOR LRE 255  85  85 255
TILEMAP_COLOR LBL  85  85 255 255
TILEMAP_COLOR LOR 255 170  85 255
TILEMAP_COLOR WHT 255 255 255 255

; 0th is no block
static PIECE_COLORMOD ints "0 0 0 0 \
                            C_CYA C_LCY C_WHT 0 \
                            C_YEL C_LYE C_WHT 0 \
                            C_PUR C_LPU C_WHT 0 \
                            C_GRN C_LGR C_WHT 0 \
                            C_RED C_LRE C_WHT 0 \
                            C_BLU C_LBL C_WHT 0 \
                            C_ORA C_LOR C_WHT 0"

static BACKGROUND_PATTERN ints "\
    BACKGROUND_TILE CLEAR_TILE CLEAR_TILE CLEAR_TILE \
    CLEAR_TILE BACKGROUND_TILE CLEAR_TILE CLEAR_TILE \
    CLEAR_TILE CLEAR_TILE BACKGROUND_TILE CLEAR_TILE \
    CLEAR_TILE CLEAR_TILE CLEAR_TILE BACKGROUND_TILE \
    CLEAR_TILE CLEAR_TILE CLEAR_TILE BACKGROUND_TILE \
    CLEAR_TILE CLEAR_TILE BACKGROUND_TILE CLEAR_TILE \
    CLEAR_TILE BACKGROUND_TILE CLEAR_TILE CLEAR_TILE \
    BACKGROUND_TILE CLEAR_TILE CLEAR_TILE CLEAR_TILE"
expr BACKGROUND_PATTERN_SIDE 4
expr BACKGROUND_PATTERN_SIZE "BACKGROUND_PATTERN_SIDE * \
                              BACKGROUND_PATTERN_SIDE"
expr BACKGROUND_PATTERN_PXSIDE "BACKGROUND_PATTERN_SIDE * TILE_SIDE"
expr BACKGROUND_WIDTH  "SCREEN_TILES_WIDTH + 4"
expr BACKGROUND_HEIGHT "SCREEN_TILES_HEIGHT + 4"
expr BACKGROUND_SIZE   "BACKGROUND_WIDTH * BACKGROUND_HEIGHT"
expr PIT_PATTERN_WIDTH  "PIT_BG_WIDTH + 4"
expr PIT_PATTERN_HEIGHT "PIT_BG_HEIGHT + 4"

proc populate_piece_values piece rotation pos width height
    local pieceptr

    ; copy values to locals to not mutate caller variables
    move pieceptr piece
    mul  pieceptr PIECEINFO_ROTATIONS
    add  pieceptr rotation

    move pos PIECEINFO_POS:pieceptr
    move width PIECEINFO_WIDTH:pieceptr
    move height PIECEINFO_HEIGHT:pieceptr
ret
 
proc rotate x y piece rotation dir
    local biasptr

    cmp dir 0
    jumpl rotate_ccw
    jumpg rotate_cw
    jump end

    label rotate_ccw
    sub rotation 1
    jumpg no_wrap_max
    jumpz no_wrap_max
    move rotation 3
    label no_wrap_max

    ; for counter clockwise, the pointer is the rotation transitioned to
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    ; for counter clockwise, the bias is subtracted (undone)
    sub x ROTATION_X_BIAS:biasptr
    sub y ROTATION_Y_BIAS:biasptr
    jump end

    label rotate_cw
    ; for clockwise, the pointer is the rotation transitioned from
    move biasptr piece
    mul  biasptr PIECEINFO_ROTATIONS
    add  biasptr rotation

    add rotation 1
    cmp rotation 4
    jumpl no_wrap_0
    move rotation 0
    label no_wrap_0

    ; for clockwise, the bias is added
    add x ROTATION_X_BIAS:biasptr
    add y ROTATION_Y_BIAS:biasptr
    
    label end
ret

expr COLLIDED_LEFT   1
expr COLLIDED_RIGHT  2
expr COLLIDED_LEFT_RIGHT "COLLIDED_LEFT | COLLIDED_RIGHT"
expr COLLIDED_TOP    4
expr COLLIDED_BOTTOM 8
expr COLLIDED_TOP_BOTTOM "COLLIDED_TOP | COLLIDED_BOTTOM"

proc check_collision collided x y pos width height
    local piecex
    local piecey
    local pitx
    local pity
    local pitpos
    local piecepos
    local pieceval
    local halfwidth
    local halfheight
    local leftx
    local rightx
    local topy
    local bottomy

    move collided 0
    ; determine ranges where a collision is determined to be to a particular
    ; side. this could be made smaller but it wouldn't necessarily be faster
    ; and would be more difficult to understand when it's already janky
    move halfwidth width
    mod  halfwidth 2
    jumpz split_width
    ; odd number.  be greedy here and count the center piece outwards for both
    ; sides.  a bottom collision could result in both being flagged but that
    ; isn't important
    ; assume that integer divisions will be floored down
    move leftx width
    div  leftx 2
    move rightx leftx
    add  leftx 1
    jump find_halfheight
    label split_width
    move leftx width
    div  leftx 2
    move rightx leftx
    label find_halfheight
    move halfheight height
    mod  halfheight 2
    jumpz split_height
    ; as above
    move topy height
    div  topy 2
    move bottomy topy
    add  topy 1
    jump done_halves
    label split_height
    move topy height
    div  topy 2
    move bottomy topy
    label done_halves

    ; check collisions with pit boundaries
    ; check top
    cmp y 0
    jumpg check_pit_bottom
    jumpz check_pit_bottom
    or collided COLLIDED_TOP

    label check_pit_bottom
    move piecey y
    add  piecey height
    cmp  piecey PIT_HEIGHT
    jumpl check_pit_left
    jumpz check_pit_left
    or collided COLLIDED_BOTTOM

    label check_pit_left
    cmp x 0
    jumpg check_pit_right
    jumpz check_pit_right
    or collided COLLIDED_LEFT

    label check_pit_right
    move piecex x
    add  piecex width
    cmp  piecex PIT_WIDTH
    jumpl check_pit
    jumpz check_pit
    or collided COLLIDED_RIGHT

    label check_pit
    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    move piecepos pos
    move piecey 0
    move pity y
    label y
        cmp pity 0
        jumpl skip_y
        cmp pity PIT_HEIGHT
        jumpg end
        jumpz end

        move piecex 0
        move pitx x
        label x
            cmp pitx 0
            jumpl skip_x
            cmp pitx PIT_WIDTH
            jumpg skip_x
            jumpz skip_x

            move pieceval pieces:piecepos
            and  pieceval pit:pitpos
            jumpz no_collision

            ; determine what halves a collision happened on
            ; left side
            cmp piecex leftx
            jumpg check_right
            jumpz check_right
            or collided COLLIDED_LEFT
            label check_right
            cmp piecex rightx
            jumpl check_top
            or collided COLLIDED_RIGHT
            label check_top
            cmp piecey topy
            jumpg check_bottom
            jumpz check_bottom
            or collided COLLIDED_TOP
            label check_bottom
            cmp piecey bottomy
            jumpl no_collision
            or collided COLLIDED_BOTTOM
            label no_collision

            label skip_x
            add piecepos 1
            add pitpos 1
            add pitx 1
            add piecex 1
            cmp piecex width
        jumpl x

        sub pitpos width
        label skip_y
        add pitpos PIT_WIDTH
        add pity 1
        add piecey 1
        cmp piecey height
    jumpl y

    label end
ret

proc try_resolve_piece_movement piece rotation x y xmove ymove dir
    local pos
    local oldwidth
    local oldheight
    local width
    local height
    local xbias
    local ybias
    local newrotation
    local widthdiff
    local heightdiff
    local leftgrowth
    local rightgrowth
    local topgrowth
    local bottomgrowth
    local checkx
    local checky
    local collided
    local priority

    ; get the current and desired new piece stats
    call populate_piece_values piece rotation pos oldwidth oldheight
    move newrotation rotation
    call rotate xbias ybias piece newrotation dir
    call populate_piece_values piece newrotation pos width height

    ; try to do the full move
    move checkx x
    add  checkx xmove
    add  checkx xbias
    move checky y
    add  checky ymove
    add  checky ybias
    call check_collision priority checkx checky pos width height
    cmp priority
    jumpz update_all

    ; compare them to see if we need to check for left/right or up/down kicks,
    ; there can only be one or the other or neither for the O piece or if no
    ; rotation happened anyway
    move widthdiff width
    sub  widthdiff oldwidth
    move heightdiff height
    sub  heightdiff oldheight

    cmp widthdiff 0
    jumpg horz_kick
    cmp heightdiff 0
    jumpg vert_kick
    ; no rotation occurred or the piece doesn't occupy additional space so it
    ; doesn't need to kick, still update rotation anyway.
    move rotation newrotation
    jump no_kick

    label horz_kick
        ; piece is "jammed", don't try
        and priority COLLIDED_LEFT_RIGHT
        cmp priority COLLIDED_LEFT_RIGHT
        jumpz no_kick

        move leftgrowth widthdiff
        move rightgrowth widthdiff

        ; apply drop, if any, as well as bias
        move checky y
        add  checky ybias
        add  checky ymove

        ; try searching outwards up to the difference in width until a
        ; collision is found, if so, back off one and use that
        label horz_kick_loop
            cmp leftgrowth 0
            jumpg horz_loop_continue
            jumpz horz_loop_continue
            cmp rightgrowth 0
            jumpg horz_loop_continue
            jumpz horz_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump horz_loop_break
            label horz_loop_continue
                and priority COLLIDED_LEFT
                jumpn try_left

            label try_right
                cmp rightgrowth 0
                jumpl continue_right

                ; try moving right incrementally until a collision
                move checkx 0
                sub  checkx rightgrowth
                add  checkx x

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub rightgrowth 1
                cmp collided
                jumpz continue_right
                ; check to see if the collision happened on the right side
                and collided COLLIDED_RIGHT
                jumpz continue_right
                ; step back 1 and use that value
                sub checkx 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_right
                and priority COLLIDED_LEFT
                jumpn horz_kick_loop

            label try_left
                cmp leftgrowth 0
                jumpl continue_left

                ; same as above
                move checkx widthdiff
                mul  checkx -1
                add  checkx leftgrowth
                add  checkx x
                
                call check_collision collided checkx checky pos width height
                ; same as above
                sub leftgrowth 1
                cmp collided
                jumpz continue_left
                and collided COLLIDED_LEFT
                jumpz continue_left

                add checkx 1
                ; check if it's still a collision, indicating there's simply
                ; not enough space to fit.
                call check_collision collided checkx checky pos width height
                cmp collided
                jumpn no_kick
            jump update_all
            label continue_left
                and priority COLLIDED_LEFT
                jumpn try_right
            jump horz_kick_loop

        label horz_loop_break
    jump no_kick

    label vert_kick
        ; should be pretty much like horz_kick just in a vertical direction
        ; since it's copypasta, comment directions may be incongruous.

        ; piece is "jammed", don't try
        and priority COLLIDED_TOP_BOTTOM
        cmp priority COLLIDED_TOP_BOTTOM
        jumpz no_kick

        move topgrowth heightdiff
        move bottomgrowth heightdiff

        ; apply movement, if any, as well as bias
        move checkx x
        add  checkx xbias
        add  checkx xmove

        ; try searching outwards up to the difference in width until a
        ; collision is found, if so, back off one and use that
        label vert_kick_loop
            cmp topgrowth 0
            jumpg vert_loop_continue
            jumpz vert_loop_continue
            cmp bottomgrowth 0
            jumpg vert_loop_continue
            jumpz vert_loop_continue
            ; all possibilities were tried and nothing was found, don't update
            ; anything, but try to see if the piece will move without rotation
            jump vert_loop_break
            label vert_loop_continue
                and priority COLLIDED_BOTTOM
                jumpz try_up

            label try_down
                cmp bottomgrowth 0
                jumpl vert_kick_loop

                ; try moving right incrementally until a collision
                move checky 0
                sub  checky bottomgrowth
                add  checky y

                call check_collision collided checkx checky pos width height
                ; subtract it now because if it collided it needs to be updated
                ; anyway, otherwise it doesn't matter
                sub bottomgrowth 1
                cmp collided
                jumpz continue_down
                ; check to see if the collision happened on the right side
                and collided COLLIDED_BOTTOM
                jumpz continue_down
                ; step back 1 and use that value
                sub checky 1
            jump update_all
            label continue_down
                cmp priority COLLIDED_BOTTOM
                jumpz vert_kick_loop

            label try_up
                cmp topgrowth 0
                jumpl vert_kick_loop

                ; same as above
                move checky heightdiff
                mul  checky -1
                add  checky rightgrowth
                add  checky y
                
                call check_collision collided checkx checky pos width height
                ; same as above
                sub topgrowth 1
                cmp collided
                jumpz continue_up
                and collided COLLIDED_TOP
                jumpz continue_up

                add checky 1
            jump update_all
            label continue_up
                cmp priority COLLIDED_TOP
                jumpn try_down
            jump vert_kick_loop

        label vert_loop_break
 
    label no_kick
        ; recalculate original position, width and height as they may have
        ; changed to a rotated state
        call populate_piece_values piece rotation pos width height

        ; try to move the piece in both requested directions
        move checkx x
        add  checkx xmove
        move checky y
        add  checky ymove
        call check_collision collided checkx checky pos width height
        cmp collided
        jumpz update_pos
        ; if either is 0, don't repeat an unnecessary test
        cmp xmove 0
        jumpz end
        cmp ymove 0
        jumpz end

        ; try to move the piece down only
        cmp ymove 0
        jumpz no_down_only
            move checkx x
            move checky y
            add  checky ymove
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
        label no_down_only

        ; try to move piece only laterally
        cmp xmove 0
        jumpz no_lateral_only
            move checkx x
            add  checkx xmove
            move checky y
            call check_collision collided checkx checky pos width height
            cmp collided
            jumpz update_pos
        label no_lateral_only
    jump end

    label update_all
        move rotation newrotation
    label update_pos
        move x checkx
        move y checky
    label end
ret

proc update_pit_map piece rotation x y
    local piecex
    local pos
    local width
    local height
    local pitpos

    call populate_piece_values piece rotation pos width height

    ; initial pit position
    move pitpos y
    mul  pitpos PIT_WIDTH
    add  pitpos x

    label y
        move piecex width

        label x
            cmp pieces:pos
            jumpz no_update
                move pit:pitpos piece
            label no_update

            add pos 1
            add pitpos 1
            sub piecex 1
        jumpg x

        ; advance to the next row of the pit
        sub pitpos width
        add pitpos PIT_WIDTH
        sub height 1
    jumpg y
ret

proc update_pit_tilemaps x y w h
    local i
    local j
    local startptr
    local ptr
    local pitval

    move startptr y
    mul  startptr PIT_WIDTH
    add  startptr x

    move ptr startptr
    move j h
    label y
        move i w
        label x
            move pitval pit:ptr
            mul  pitval TILEMAP_WIDTH
            move pit_map0_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map0_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map1_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map1_colormod:ptr PIECE_COLORMOD:pitval
            add  pitval 1
            move pit_map2_tiles:ptr PIECE_TILEMAP:pitval
            move pit_map2_colormod:ptr PIECE_COLORMOD:pitval
            sub  pitval 2

            add ptr 1
            sub i 1
        jumpg x
        sub ptr w
        add ptr PIT_WIDTH
        sub j 1
    jumpg y

    ; set tiles and attributes then update
    call gfx_set_tilemap_map3 pit_tilemap_id0 pit_map0_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id0 pit_map0_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id0 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id1 pit_map1_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id1 pit_map1_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id1 x y w h
    call gfx_set_tilemap_map3 pit_tilemap_id2 pit_map2_tiles:startptr x y PIT_WIDTH w h
    call gfx_set_tilemap_attr_colormod3 pit_tilemap_id2 pit_map2_colormod:startptr x y PIT_WIDTH w h
    call gfx_update_tilemap2 pit_tilemap_id2 x y w h
ret

proc update_pit_tilemaps_from_piece piece rotation x y
    local pos
    local width
    local height

    call populate_piece_values piece rotation pos width height
    call update_pit_tilemaps x y width height
ret

proc drop_line line
    local block
    local curline
    local pitpos
    local abovepitpos

    move curline line

    ; start at the end of the line
    move pitpos line
    mul  pitpos PIT_WIDTH
    add  pitpos PIT_WIDTH
    sub  pitpos 1
    ; end of line above to copy from
    move abovepitpos pitpos
    sub  abovepitpos PIT_WIDTH

    label line
        move block PIT_WIDTH
        label block
            cmp abovepitpos 0
            jumpl set_zero
            move pit:pitpos pit:abovepitpos
            jump done_set
            label set_zero
            move pit:pitpos 0
            label done_set

            sub pitpos 1
            sub abovepitpos 1
            sub block 1
        jumpg block

        sub curline 1
    jumpg line
    jumpz line
ret

proc check_lines lines y height
    local pitpos
    local line
    local maxline
    local block
    local blocks

    move lines 0

    move maxline y
    add  maxline height

    move pitpos y
    mul  pitpos PIT_WIDTH

    move line y
    label line
        move block PIT_WIDTH
        move blocks 0
        label block
            cmp pit:pitpos
            jumpz noblock
            add blocks 1
            label noblock

            add pitpos 1
            sub block 1
        jumpg block
        cmp PIT_WIDTH blocks
        jumpg noclear
        call drop_line line
        add lines 1
        label noclear

        add line 1
        cmp line maxline
    jumpl line
ret

proc draw_pit
    move gfx_draw_layer pit_shadow_layer_id
    move gfx_draw_layer pit_pattern1_layer_id
    move gfx_draw_layer pit_pattern0_layer_id
    move gfx_draw_layer pit_background_layer_id
    move gfx_draw_layer pit_layer_id0
    move gfx_draw_layer pit_layer_id1
    move gfx_draw_layer pit_layer_id2
ret

proc draw_piece layer_id piece rotation x y
    local scaledx
    local scaledy
    local piecex
    local pos
    local width
    local height
    local window ints 2
    local position floats "0.0 0.0"
    local intPosition ints 2
    local scaled_tile floats 0.0

    call populate_piece_values piece rotation pos width height

    ; initial tilemap position
    move window:1 piece
    mul  window:1 TILE_SIDE 

    ; size of a tile in float which will be used to accumulate location
    move scaled_tile TILE_SIDE
    mul  scaled_tile objects_global_scale

    ; get the starting scaled position
    move scaledx x
    mul  scaledx objects_global_scale
    add  scaledx objects_global_offset:0
    move scaledy y
    mul  scaledy objects_global_scale
    add  scaledy objects_global_offset:1

    ; get initial y position
    move position:1 scaledy
 
    label y
        ; copy in to a storage useful by gfx
        move intPosition:1 position:1

        ; get initial x position
        move position:0 scaledx
        move piecex width
        label x
            cmp pieces:pos
            jumpz nodraw

            ; copy to an int to be useful by gfx
            move intPosition:0 position:0
            move gfx_set_layer_pos:layer_id intPosition
            move window:0 0
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            add  window:0 TILE_SIDE
            move gfx_set_layer_scroll_pos:layer_id window
            move gfx_draw_layer layer_id
            label nodraw

            ; advance table pointer
            add pos 1
            ; calculate next x position
            add position:0 scaled_tile
            sub piecex 1
        jumpg x

        ; calculate next y position
        add position:1 scaled_tile
        sub height 1
    jumpg y 
ret

static gfx_id
static font_id
static block_tilemap_id
static block_layer_id
static pit_tilemap_id0
static pit_tilemap_id1
static pit_tilemap_id2
static pit_layer_id0
static pit_layer_id1
static pit_layer_id2
static pit_background_id
static pit_background_layer_id
static window_background_id
static window_background_layer_id
static window_pattern_id
static window_pattern0_layer_id
static window_pattern1_layer_id
static pit_shadow_id
static pit_shadow_layer_id
static pit_pattern_id
static pit_pattern0_layer_id
static pit_pattern1_layer_id
static controls_tilemap_id
static controls_layer0_id
static controls_layer1_id

static block_obj
static pit0_obj
static pit1_obj
static pit2_obj
static pit_bg_obj
static win_bg_obj
static pit_sh_obj
static win_pat0_obj
static win_pat1_obj
static pit_pat0_obj
static pit_pat1_obj
static controls0_obj
static controls1_obj

static pitxpos
static pitypos

macro UPDATE_LEVEL
    move nextlines level
    mul  nextlines LINES_PER_LEVEL
    TIMERS_SET_RATE piece_timer_id LEVEL_CHANGE_RATES:level
    move gfx_set_layer_colormod:window_background_layer_id LEVEL_BG_COLOR:level
    move gfx_set_layer_colormod:pit_shadow_layer_id LEVEL_BG_SHADOW_COLOR:level
    move gfx_set_layer_colormod:controls_layer0_id LEVEL_BG_SHADOW_COLOR:level
endmacro UPDATE_LEVEL

static fps_timer_id
static piece_timer_id
static input_timer_id
static bgscroll_timer_id

static bgscroll0 ints 2
static bgscroll1 ints 2
static bgscroll2 ints 2
static bgscroll3 ints 2

proc init
    local temp ints 4
    local tempf floats "0.0 0.0 0.0 0.0"
    local pitbg ints PIT_BG_SIZE 
    local pitflags ints PIT_BG_SIZE 
    local pitcolormod ints PIT_BG_SIZE
    local row ints SCREEN_TILES_WIDTH
    local background_pattern ints BACKGROUND_SIZE

    call set_video_mode temp videomode
    cmp temp
    jumpn mode_ok
    move set_running 0
    jump end
    label mode_ok

    call timers_clear
    call objects_setup
    OBJECTS_SET_SCREEN_SIZE SCREEN_WIDTH SCREEN_HEIGHT

    move temp:0 gfx:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset gfx:CRSG_OFFSET_DATA gfx:CRSG_OFFSET_WIDTH gfx:CRSG_OFFSET_HEIGHT temp:0 TILE_SIDE TILE_SIDE gfx_id

    move temp:0 font:CRSG_OFFSET_WIDTH
    mul  temp:0 TILEMAP_PIXEL_BYTES
    call gfx_add_tileset font:CRSG_OFFSET_DATA font:CRSG_OFFSET_WIDTH font:CRSG_OFFSET_HEIGHT temp:0 FONT_SIDE FONT_SIDE font_id

    call gfx_add_tilemap TILEMAP_WIDTH TILEMAP_HEIGHT block_tilemap_id
    move gfx_set_tilemap_tileset:block_tilemap_id gfx_id
    call gfx_set_tilemap_map block_tilemap_id PIECE_TILEMAP
    call gfx_set_tilemap_attr_colormod block_tilemap_id PIECE_COLORMOD
    call gfx_update_tilemap block_tilemap_id
    call gfx_add_layer block_tilemap_id block_layer_id
    call objects_get_free block_obj block_layer_id
    ; set some parameter otherwise it won't be updated right away
    OBJECTS_SET_SCALE block_obj 1 1
    move temp:0 TILE_SIDE
    move temp:1 TILE_SIDE
    move gfx_set_layer_window:block_layer_id temp
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_background_id
    move gfx_set_tilemap_tileset:pit_background_id gfx_id
    call gfx_add_layer pit_background_id pit_background_layer_id
    call objects_get_free pit_bg_obj pit_background_layer_id

    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id0
    move gfx_set_tilemap_tileset:pit_tilemap_id0 gfx_id
    call gfx_add_layer pit_tilemap_id0 pit_layer_id0
    call objects_get_free pit0_obj pit_layer_id0
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id1
    move gfx_set_tilemap_tileset:pit_tilemap_id1 gfx_id
    call gfx_add_layer pit_tilemap_id1 pit_layer_id1
    call objects_get_free pit1_obj pit_layer_id1
    call gfx_add_tilemap PIT_WIDTH PIT_HEIGHT pit_tilemap_id2
    move gfx_set_tilemap_tileset:pit_tilemap_id2 gfx_id
    call gfx_add_layer pit_tilemap_id2 pit_layer_id2
    call objects_get_free pit2_obj pit_layer_id2
  
    ; don't really care that pit* aren't static because the background is only
    ; set up once and it doesn't matter if the pointer becomes invalid.
    call fill_with_border pitbg PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_FILL PIT_TILE_EDGE PIT_TILE_CORNER PIT_TILE_EDGE PIT_TILE_CORNER
    call gfx_set_tilemap_map pit_background_id pitbg
    call fill_with_border pitflags PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH 0 0 TILEMAP_HFLIP_MASK TILEMAP_ROTATE_90 0 TILEMAP_ROTATE_90 TILEMAP_VFLIP_MASK 0 TILEMAP_BFLIP_MASK
    call gfx_set_tilemap_attr_flags pit_background_id pitflags
    call fill_with_border pitcolormod PIT_BG_WIDTH PIT_BG_HEIGHT PIT_BG_WIDTH C_WHT C_WHT C_WHT C_WHT C_PIT_FILL C_WHT C_WHT C_WHT C_WHT
    call gfx_set_tilemap_attr_colormod pit_background_id pitcolormod
    call gfx_update_tilemap pit_background_id
    
    call gfx_add_tilemap PIT_BG_WIDTH PIT_BG_HEIGHT pit_shadow_id
    move gfx_set_tilemap_tileset:pit_shadow_id gfx_id
    call gfx_add_layer pit_shadow_id pit_shadow_layer_id
    call objects_get_free pit_sh_obj pit_shadow_id
    call fill row PIT_BG_WIDTH 1 PIT_BG_WIDTH SOLID_TILE
    call gfx_set_tilemap_map3 pit_shadow_id row 0 0 0 PIT_BG_WIDTH PIT_BG_HEIGHT
    call gfx_update_tilemap pit_shadow_id

    call gfx_add_tilemap SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT window_background_id
    move gfx_set_tilemap_tileset:window_background_id gfx_id
    call gfx_add_layer window_background_id window_background_layer_id
    call objects_get_free win_bg_obj window_background_layer_id
    OBJECTS_SET_POS win_bg_obj 0 0
    call fill row SCREEN_TILES_WIDTH 1 SCREEN_TILES_WIDTH SOLID_TILE
    ; pitch = 0 so the same row is copied for each row
    call gfx_set_tilemap_map3 window_background_id row 0 0 0 SCREEN_TILES_WIDTH SCREEN_TILES_HEIGHT
    call gfx_update_tilemap window_background_id

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap BACKGROUND_WIDTH BACKGROUND_HEIGHT window_pattern_id
    move gfx_set_tilemap_tileset:window_pattern_id gfx_id
    call gfx_set_tilemap_map window_pattern_id background_pattern
    call gfx_update_tilemap window_pattern_id
    call gfx_add_layer window_pattern_id window_pattern0_layer_id
    call gfx_add_layer window_pattern_id window_pattern1_layer_id
    move temp:0 SCREEN_TILES_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 SCREEN_TILES_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:window_pattern0_layer_id temp
    move gfx_set_layer_window:window_pattern1_layer_id temp
    move gfx_set_layer_blendmode:window_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:window_pattern1_layer_id C_BG_PATTERN_SHADOW
    call objects_get_free win_pat0_obj window_pattern0_layer_id
    OBJECTS_SET_POS win_pat0_obj 0 0
    call objects_get_free win_pat1_obj window_pattern1_layer_id
    OBJECTS_SET_POS win_pat1_obj 0 0

    call fill_with_pattern background_pattern BACKGROUND_WIDTH BACKGROUND_HEIGHT BACKGROUND_WIDTH BACKGROUND_PATTERN:BACKGROUND_PATTERN_SIZE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE BACKGROUND_PATTERN_SIDE

    call gfx_add_tilemap PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT pit_pattern_id
    move gfx_set_tilemap_tileset:pit_pattern_id gfx_id
    call gfx_set_tilemap_map3 pit_pattern_id background_pattern 0 0 BACKGROUND_WIDTH PIT_PATTERN_WIDTH PIT_PATTERN_HEIGHT
    call gfx_update_tilemap pit_pattern_id
    call gfx_add_layer pit_pattern_id pit_pattern0_layer_id
    call gfx_add_layer pit_pattern_id pit_pattern1_layer_id
    move temp:0 PIT_BG_WIDTH
    mul  temp:0 TILE_SIDE
    move temp:1 PIT_BG_HEIGHT
    mul  temp:1 TILE_SIDE
    move gfx_set_layer_window:pit_pattern0_layer_id temp
    move gfx_set_layer_window:pit_pattern1_layer_id temp
    move gfx_set_layer_blendmode:pit_pattern1_layer_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:pit_pattern1_layer_id C_BG_PATTERN_SHADOW
    call objects_get_free pit_pat0_obj pit_pattern0_layer_id
    call objects_get_free pit_pat1_obj pit_pattern1_layer_id

    call gfx_add_tilemap CONTROLS_TILEMAP_WIDTH CONTROLS_TILEMAP_HEIGHT controls_tilemap_id
    move gfx_set_tilemap_tileset:controls_tilemap_id font_id
    call text_string_to_tilemap controls_tilemap CONTROLS_TILEMAP_WIDTH CONTROLS_TILEMAP_HEIGHT CONTROLS_TILEMAP_WIDTH CONTROLS_TEXT
    call gfx_set_tilemap_map controls_tilemap_id controls_tilemap
    call gfx_update_tilemap controls_tilemap_id
    call gfx_add_layer controls_tilemap_id controls_layer0_id
    call gfx_add_layer controls_tilemap_id controls_layer1_id
    move gfx_set_layer_blendmode:controls_layer1_id GFX_BLENDMODE_SUB
    move gfx_set_layer_colormod:controls_layer1_id C_BG_PATTERN_SHADOW
    call objects_get_free controls0_obj controls_layer0_id
    call objects_get_free controls1_obj controls_layer1_id
    OBJECTS_SET_POS_AND_SCALE controls0_obj FONT_SIDE FONT_SIDE 2 2
    move temp:0 FONT_SIDE
    add  temp:0 1
    OBJECTS_SET_POS_AND_SCALE controls1_obj temp:0 temp:0 2 2

    ; update the whole pit
    call update_pit_tilemaps 0 0 PIT_WIDTH PIT_HEIGHT

    ; center the pit
    move tempf:0 SCREEN_WIDTH
    move tempf:2 PIT_WIDTH
    mul  tempf:2 TILE_SIDE
    sub  tempf:0 tempf:2
    div  tempf:0 2
    move tempf:1 SCREEN_HEIGHT
    move tempf:2 PIT_HEIGHT
    mul  tempf:2 TILE_SIDE
    sub  tempf:1 tempf:2
    div  tempf:1 2
    move tempf:2 tempf:0
    move tempf:3 tempf:1
    sub  tempf:2 TILE_SIDE
    sub  tempf:3 TILE_SIDE
    move pitxpos tempf:0
    move pitypos tempf:1
    OBJECTS_SET_POS pit0_obj pitxpos pitypos
    OBJECTS_SET_POS pit1_obj pitxpos pitypos
    OBJECTS_SET_POS pit2_obj pitxpos pitypos
    move temp:0 tempf:2
    move temp:1 tempf:3
    OBJECTS_SET_POS pit_bg_obj temp:0 temp:1
    OBJECTS_SET_POS pit_sh_obj pitxpos pitypos
    OBJECTS_SET_POS pit_pat0_obj pitxpos pitypos
    OBJECTS_SET_POS pit_pat1_obj pitxpos pitypos

    call timers_get_free fps_timer_id 1000
    ; not ready to get this one going yet but just get the ID
    call timers_get_free piece_timer_id 0
    call timers_get_free input_timer_id INPUT_DELAY
    call timers_get_free bgscroll_timer_id BGSCROLL_DELAY

    move bgscroll0:0 0
    move bgscroll0:1 0
    move bgscroll1:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:0 1
    move bgscroll1:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll1:1 1
    move bgscroll2:0 0
    move bgscroll2:1 0
    move bgscroll3:0 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:0 1
    move bgscroll3:1 BACKGROUND_PATTERN_PXSIDE
    sub  bgscroll3:1 1
    move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
    move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
    move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
    move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3

    UPDATE_LEVEL

    label end
ret

static fps

proc count_fps
    local elapsed

    call timers_check elapsed fps_timer_id
    cmp elapsed
    jumpz fps_continue
    move err fps
    move err NL
    move fps 0

    label fps_continue
    add fps 1
ret

proc pit_effect
    local piece
    local rotation
    local width
    local height
    local pos
    local maxx
    local maxy
    local x
    local y

    move piece get_random
    mod  piece PIECEINFO_PIECES
    add  piece 1
    move rotation get_random
    mod  rotation PIECEINFO_ROTATIONS

    call populate_piece_values piece rotation pos width height

    move maxx PIT_WIDTH
    sub  maxx width
    add  maxx 1
    move maxy PIT_HEIGHT
    sub  maxy height
    add  maxy 1
    move x get_random
    mod  x maxx
    move y get_random
    mod  y maxy

    call update_pit_map piece rotation x y
    call update_pit_tilemaps_from_piece piece rotation x y
ret

macro ADVANCE_BGSCROLL VAR DIR MAX
    add VAR DIR
    cmp VAR MAX
    jumpz wrap_VAR_0
    cmp VAR 0
    jumpl wrap_VAR_max
    jump wrap_VAR_done
    label wrap_VAR_0
    move VAR 0
    jump wrap_VAR_done
    label wrap_VAR_max
    move VAR MAX
    sub  VAR 1
    label wrap_VAR_done
endmacro ADVANCE_BGSCROLL

static level STARTING_LEVEL
static curpiece DEBUG_START_PIECE
static currotation
static xpos 0
static ypos 0
static lastmove 0
static move 0
static tapped 0
static fall 0
static rotate 0
static lines_cleared 0
static nextlines

proc frame
    local curTick
    local width
    local height
    local pos
    local elapsed
    local xmove
    local ymove
    local collided
    local lines

;    call count_fps

    cmp game_mode GAME_MODE_ENDED
    jumpz done_update

    cmp curpiece
    jumpn have_piece
        move curpiece get_random
        mod  curpiece PIECEINFO_PIECES
        add  curpiece 1
        move currotation 0
        move ypos 0
        call populate_piece_values curpiece currotation pos width height
        move xpos PIT_WIDTH
        sub  xpos width
        div  xpos 2

        call check_collision collided xpos ymove pos width height
        cmp collided
        jumpz have_piece
        move game_mode GAME_MODE_ENDED
        call update_pit_map curpiece currotation xpos ypos
        call update_pit_tilemaps_from_piece curpiece currotation xpos ypos
        jump done_update
    label have_piece

    ; nothing to do if lastmove and move are equal since there's no state to
    ; transition to
    cmp lastmove move
    jumpz done_tap

    cmp move 0
    jumpl tap_left
    jumpg tap_right
    ; transition to 0, rearm to allow more tapping.
    move lastmove 0
    jump done_tap

    label tap_left
    cmp move lastmove
    jumpz done_tap
    ; transition to left, move left and set lastmove to move to make sure a
    ; tap isn't signaled until lastmove has been reset back to 0 if the user
    ; has indicated to stop.  initialize tapped to allow a delay before the
    ; motion repeats.
    move xmove -1
    move lastmove move
    move tapped TAP_DELAY
    jump done_tap

    label tap_right
    cmp move lastmove
    jumpz done_tap
    ; same as above
    move xmove 1
    move lastmove move
    move tapped TAP_DELAY
    label done_tap

    call timers_check elapsed input_timer_id
    cmp elapsed
    jumpz done_repeat

    cmp fall
    jumpz no_fall
    move ymove 1
    label no_fall

    ; the timer has elapsed, check to see if lastmove and move are equal,
    ; tapped is 0 (and if not, decrease it), then figure out what to do with
    ; move
    cmp move lastmove
    jumpn done_repeat
    cmp tapped 0
    jumpn dec_tapped
    cmp move 0
    jumpl move_left
    jumpg move_right
    jump done_repeat

    label move_left
    move xmove -1
    jump done_repeat

    label move_right
    move xmove 1
    jump done_repeat

    label dec_tapped
    sub tapped 1
    label done_repeat

    call try_resolve_piece_movement curpiece currotation xpos ypos xmove ymove rotate
    ; reset rotation so it only happens once
    move rotate 0

    call timers_check elapsed piece_timer_id
    cmp elapsed
    jumpz done_update
    move ymove ypos
    add  ymove DEBUG_DO_PIECE_FALL

    ; repopulate because they may have changed
    call populate_piece_values curpiece currotation pos width height
    ; check to see if moving down would collide, and if so, plant the piece
    call check_collision collided xpos ymove pos width height
    cmp  collided
    jumpn plant_piece
    move ypos ymove
    jump done_update

    label plant_piece
        call update_pit_map curpiece currotation xpos ypos
        call check_lines lines ypos height
        cmp lines
        jumpg update_pit_lines
        call update_pit_tilemaps_from_piece curpiece currotation xpos ypos
        jump done_pit_updates
        label update_pit_lines
        add lines_cleared lines
        cmp lines_cleared nextlines
        jumpl no_next_level
        cmp level MAX_LEVEL
        jumpz no_next_level
        add level 1
        ERR_NL level
        UPDATE_LEVEL
        label no_next_level
        ; update the pit up to the line the piece fell to
        add height ypos
        call update_pit_tilemaps 0 0 PIT_WIDTH height
        label done_pit_updates
        ; signal piece reset
        move curpiece 0

    label done_update
        call timers_check elapsed bgscroll_timer_id
        jumpz no_bgscroll
        ADVANCE_BGSCROLL bgscroll0:0 1  BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll0:1 -1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll1:0 1  BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll1:1 -1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll2:0 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll2:1 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll3:0 1 BACKGROUND_PATTERN_PXSIDE
        ADVANCE_BGSCROLL bgscroll3:1 1 BACKGROUND_PATTERN_PXSIDE

        move gfx_set_layer_scroll_pos:window_pattern0_layer_id bgscroll0
        move gfx_set_layer_scroll_pos:window_pattern1_layer_id bgscroll1
        move gfx_set_layer_scroll_pos:pit_pattern0_layer_id bgscroll2
        move gfx_set_layer_scroll_pos:pit_pattern1_layer_id bgscroll3
        label no_bgscroll
        move gfx_draw_layer window_background_layer_id
        move gfx_draw_layer window_pattern1_layer_id
        move gfx_draw_layer window_pattern0_layer_id
        call draw_pit
        move xmove xpos
        mul  xmove TILE_SIDE
        add  xmove pitxpos
        move ymove ypos
        mul  ymove TILE_SIDE
        add  ymove pitypos
        call draw_piece block_layer_id curpiece currotation xmove ymove
        move gfx_draw_layer controls_layer1_id
        move gfx_draw_layer controls_layer0_id

    label end
ret

proc event
    cmp event_get_type INPUT_TYPE_KEYDOWN
    jumpn keyup
    cmp event_get_button INPUT_KEY_f
    jumpz toggle_fullscreen
    cmp event_get_button INPUT_KEY_ESCAPE
    jumpz quit
    cmp event_get_button INPUT_KEY_a
    jumpz move_left
    cmp event_get_button INPUT_KEY_d
    jumpz move_right
    cmp event_get_button INPUT_KEY_q
    jumpz rotate_left
    cmp event_get_button INPUT_KEY_e
    jumpz rotate_right
    cmp event_get_button INPUT_KEY_s
    jumpz fall
    jump end

    label toggle_fullscreen
        call toggle_fullscreen
        call objects_update_global_scale
        call objects_update_scales
    jump end

    label quit
        move set_running 0
    jump end

    label move_left
        move move -1
    jump end

    label move_right
        move move 1
    jump end

    label rotate_left
        move rotate -1
    jump end

    label rotate_right
        move rotate 1
    jump end

    label fall
        move fall 1
    jump end

    label keyup
    cmp event_get_type INPUT_TYPE_KEYUP
    jumpn end
    cmp event_get_button INPUT_KEY_a
    jumpz no_move_left
    cmp event_get_button INPUT_KEY_d
    jumpz no_move_right
    cmp event_get_button INPUT_KEY_s
    jumpz nofall
    jump end

    label no_move_left
        cmp move 0
        jumpg end
        move move 0
    jump end

    label no_move_right
        cmp move 0
        jumpl end
        move move 0
    jump end

    label nofall
        move fall 0
    jump end
 
    label end
ret
